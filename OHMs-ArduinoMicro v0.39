
//#####################################################
//#####################################################

// Open Horn Midi system / "OHMs"
// Arduino Micro - Main Code v0.38
// Copyright 2014, Jeppe Tofth√∏j Rasmussen

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//#####################################################
//#####################################################

#include <SoftwareSerial.h>
#include <Wire.h>

//##############################################################
//##############################################################
// Velocity based output / after-touch based output




/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// KEY AND NOTE VARIABLES:

//Array of all pins with resistive touch switches - In descending fingering order:
//             "" oUp oDn sF  B  A  G  G# A# F  E   D   D# ""
byte keyPins[] = {
  A1, A2, A3,   4,  5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
//(octaves)     HD  B  A  G  Ab Bb LC  F   E   D   Eb  LC/LBb
 
//        Pin = 14; // MISO pin
//        Pin = 15; // SCK pin
#define NUMKEYS sizeof(keyPins)

#define NUMNOTEKEYS 12

//Fingering-arrays. Here I store all the different key combinations, in relation to the pins the keys are on.
// These arrays correspond to the "keyPins[]" array from [3] to [11], so pins from 4 - 12 carry these "note-defining" keys.
// The last three keys/pins are for octave and "special functions" and they are treated separately.

byte highEFlat[NUMNOTEKEYS] = {
  1,  0, 0, 0,  0, 1, 0,  0, 0, 0,  0, 0};
byte highDNat[NUMNOTEKEYS] = {
  1,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte cSharp[NUMNOTEKEYS] = {
  0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte cNat[NUMNOTEKEYS] = {
  0,  0, 1, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte bNat[NUMNOTEKEYS] = {
  0,  1, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte bFlat[NUMNOTEKEYS] = {
  0,  1, 1, 0,  0, 1, 0,  0, 0, 0,  0, 0};
byte aNat[NUMNOTEKEYS] = {
  0,  1, 1, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte aFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  1, 0, 0,  0, 0, 0,  0, 0};
byte gNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  0, 0, 0,  0, 0};
byte fSharp[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  0, 1, 0,  0, 0};
byte fNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 0, 0,  0, 0};
byte eNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 0,  0, 0};
byte eFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  1, 0};
byte dNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  0, 0};
 
byte lowCSharp[NUMNOTEKEYS] = {
  0,  1, 1, 1,  1, 0, 0,  1, 1, 1,  0, 1};
byte lowCNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  0, 1};
byte lowBNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 1,  1, 1, 1,  0, 0};
byte lowBFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 1,  1, 1, 1,  0, 1};
 



//Main array which stores the current state of each key pin:
byte keysPressed[NUMKEYS];

// Another array which stores the previous state for comparison:
byte lastPressed[NUMKEYS];

// A shorter version of the original key-array, with the octave key pins removed
byte noteKeysPressed[NUMNOTEKEYS];
boolean newKeys;

byte baseNote; // This is the initial reading of the note, and stores one of 18 notes between lowBFlat and highEFlat (46-63)
byte currentNote; // This is the complete, calculated note, including octave.
byte lastNote; // This is the last played note, for comparison with new readings.
int octave = 0; // A value between -48 and 60 (in increments of 12). Set by setOctave()
int lastOctave = 0;




////////////////////////////////////////////
// BEND VARIABLES:
byte bendPin = A5; // Pin with the bend sensor on it

//pitchbend data storage:
byte lsb = 0;//least siginificant byte of pitchbend message (for 127 step resolution, this stays at 0)
byte bendTemp;
byte bendVal = 64;// (msb) most significant byte of pitchbend message (Bend values from 0 - 127. 64 means no pitchbend)
byte lastBend = 64;
byte refBend;
int potm;

byte bendCenter;
byte bendLowBuf = 8;
byte bendHighBuf = 8;



//#####################################################################
//#####################################################################
// FSR VARIABLES (Bite and Breath sensors):

byte bitePin = A0; // Pin with the bite sensor on it
int biteRead = 0;
byte biteVal = 0;
byte lastBite = 0;
byte harmonic = 0;

// harmonic limit constants for bite sensor:

//const byte firstHarmonic = 800;
//const byte secondHarmonic = 500;
//const byte thirdHarmonic = 350;
//const byte fourthHarmonic = 275;
//const byte fifthHarmonic = 225;
//const byte sixthHarmonic = 190;
//const byte seventhHarmonic = 175;



byte fsrBreathPin = A4; // Pin with the breath sensor on it
int fsrBreathRead;
int fsrBreathTemp;
int fsrBreathCalc;
byte fsrBreathPressure;
byte fsrBreathSaved;

byte velocity;     // This holds the mapped value of the currentPressure reading. Always a byte from 0-127.
byte lastVelocity; // This holds the last velocity value for comparison

int newVelocity = 0;

///////////////////////////////////
//Median filter / Sort variables:
int arraySize = 10;
int breathArray[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };





///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// MIDI VARIABLES:


////////MIDI Commands:
byte noteON = 144;//144 = 10010000 in binary, this is the standard note on command
byte pitchBend = 224;//224 = 11100000 in binary, this is the standard pitchbend command
byte continuousController = 176;
byte sostenuto = 66;
byte footController = 4;
byte bankSelect = 0;
byte modulationControl = 1;


boolean sendMessage = 0; // If either of velocity, note or pitchBend have changed since last reading, this variable
// is set to 1, and a new midi message will be sent this time around the loop.

//Pin = 14; // MISO pin
//Pin = 15; // SCK pin
//Pin = 16; // MOSI pin

////Create a SoftwareSerial instance for sending MIDI commands out.
SoftwareSerial midiSerial(-1, 16);

byte Effect5Depth = 95;
byte Effect2Depth = 92;

// Serial 1-pin LCD setup:
// SoftwareSerial LCDSerial(-1, 16);




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// ROTARY ENCODER VARIABLES:

int rotEncPin1 = 0;
int rotEncPin2 = 1;
int rotEncButtonPin = A4;

volatile long lastEncoded = 0;
volatile long encoderValue = 0;
volatile long encoderOutput = 0;
volatile long lastEncoderOutput = 0;




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// LCD MENU VARIABLES:

//mainMenuItems[] = {"1: PICK INSTRUMENT", "2: ADJUST BREATH", "3: CALIBRATE BEND", "4: PLAYING MODES", 
//
//breathMenuItems[] = {"A: ADJUST SENSITIVITY", "B: ADJUST BUFFER", "C: SET NEW REFERENCE", 
//
//modeMenuItems[] = {"A: NORMAL", "B: SUSTAIN", "C: CHORDS", "D: INTERVALS", 
//


// "OHMS MAIN MENU:"
// 1. 

// (scroll:)
// 2.
// 3.

// "OHMS MODES:"



///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// SETUP:

void setup(){
  delay(5000);
  byte i;
  for (i=0; i < NUMKEYS; i++){
    pinMode(keyPins[i], INPUT);
    digitalWrite(keyPins[i], HIGH);
  }
  Serial.begin(9600);
  midiSerial.begin(31250);


  // ROTARY ENCODER SETUP:
  pinMode(rotEncPin1, INPUT);
  pinMode(rotEncPin2, INPUT);
  pinMode(rotEncButtonPin, INPUT);

  digitalWrite(rotEncPin1, HIGH); //turn pullup resistor on
  digitalWrite(rotEncPin2, HIGH); //turn pullup resistor on
  digitalWrite(rotEncButtonPin, HIGH); //turn pullup resistor on

  //call updateEncoder() when any high/low change seen
  //on interrupt 2 (pin 0), or interrupt 3 (pin 1)
  attachInterrupt(2, rotEncUpdate, CHANGE);
  attachInterrupt(3, rotEncUpdate, CHANGE);
 
  potm = analogRead(bendPin);
  bendCenter = map(potm, 451, 670, 0, 127);
  bendLowBuf = bendCenter - 5;
  bendHighBuf = bendCenter + 5;
}





//#################################################################
//#################################################################
//############ MAIN LOOP:


void loop(){
  int n;
  byte i;
//  timer1 = millis();              // Update timer1, to keep track of the pressure sensor wait time
//


  updatePressure();               // Updates pressure and velocity values
  if(velocity != lastVelocity){
    sendMessage = 1;
  }    
  
  
  
  readKeys(); // This populates the "keysPressed[]" array with fresh readings from the 12 touch pins

    /////////////////////////////////////////////////
  //// Debug for "readKeys()" only:
  //  for (i = 0; i < NUMKEYS; i++){
  //    Serial.print(keysPressed[i]);
  //  }
  //  Serial.println();
  // // End debug /////////////////////////////////



  pickNote();                    // picknote() function sets the "baseNote" as a
  // midi note pitch, by comparing "keysPressed[]" to all accepted key combinations.



  setOctave();                  // setOctave() function keeps track of the octave keys in the keysPressed[] array,
                           // and updates it as an int between -48 and 60 (in increments of 12), which is
                           // added to / subtracted from the note value
 


  currentNote = baseNote + octave;  //Calculate final note value for midi, including octave



  if(currentNote != lastNote){   // Check for new note.
    sendMessage = 1;             // In case of new note, request new midi message
  }

//  rotEncUpdate();
//  if(encoderOutput != lastEncoderOutput){
//    lastEncoderOutput = encoderOutput;
//    sendMessage = 1;
//  }

  ////////////////////////////////////////////
  // Run the readBend function to update "bendValue":
  readBend();  // Updates the bend value from the neck sensor and maps it to 0 - 127.
  if(bendVal != lastBend){
    sendMessage = 1;

  }

//  readBite();
//  if(biteVal != lastBite){
//    sendMessage = 1;
//  }



//###############################################
//######## MIDI MESSAGE SECTION:


  if(sendMessage == 1){

    if(currentNote != lastNote){
      sendMidi(noteON, currentNote, velocity);
      sendMidi(noteON, lastNote, 0);
    }
    else if(velocity != lastVelocity){
      sendMidi(continuousController, 2, velocity);
    }   

    if(velocity != 0 && lastVelocity == 0){
      sendMidi(noteON, currentNote, velocity);
    }

    if(velocity == 0){
      sendMidi(noteON, currentNote, 0);
      sendMidi(noteON, lastNote, 0);
    }

    if(bendVal != lastBend){
      sendMidi(pitchBend, 0, bendVal);
    }
//    if(biteVal != lastBite){
//      sendMidi(modulationControl, 0, biteVal);
//      lastBite = biteVal;
//    }

    fsrBreathSaved = fsrBreathPressure;
    lastVelocity = velocity;
    lastNote = currentNote;
    lastBend = bendVal;



//#######################        
//######### MAIN DEBUG:

    if(sendMessage == 1){
      Serial.println();
  //    Serial.print("Reference pressure:       ");
  //    Serial.println(refPressure);
  //    Serial.print("Current pressure:         ");
  //    Serial.println(currentPressure);
      Serial.print("Velocity:      ");
      Serial.println(velocity);
      Serial.print("Current Note:             ");
      Serial.println(currentNote);
      Serial.print("Note bend value:          ");
      Serial.println(bendVal);
      Serial.print("Rotary encoder position:  ");
      Serial.println(encoderOutput);
      delay(20);
    }


    sendMessage = 0;

  }
} // End of main loop
////////////////////////////////////////
///////////////////////////////////////





//#################################################################
//######################### Functions: ############################
//#################################################################





//###################################################################
//############ FSR Breath pressure function - Sets velocity:

void updatePressure(){
  int i;
  for(i = 0; i < arraySize; i++){    
    fsrBreathTemp = analogRead(fsrBreathPin);
    breathArray[i] = fsrBreathTemp;
  }
  isort(breathArray,arraySize);
  fsrBreathRead = breathArray[arraySize / 2];
  if(fsrBreathRead > 780){   
    fsrBreathPressure = map(fsrBreathRead, 1023, 781, 0, 50);
  }
  else if(fsrBreathRead <= 780){   
    fsrBreathPressure = map(fsrBreathRead, 780, 500, 51, 127);
  }
  if(fsrBreathPressure > 127){
    fsrBreathPressure = 127;
  }
  if(fsrBreathPressure != fsrBreathSaved){
    velocity = fsrBreathPressure;
    fsrBreathSaved = fsrBreathPressure;
  }
}



//###################################################################
//###################################################################
// SORT FUNCTION FOR THE MEDIAN FILTER ON BREATH DATA:

void isort(int *a, int n){
// *a is an array pointer function - n is the array size

  for (int i = 1; i < n; ++i)
  {
    int j = a[i];
    int k;
    for (k = i - 1; (k >= 0) && (j < a[k]); k--)
    {
      a[k + 1] = a[k];
    }
    a[k + 1] = j;
  }

} 

//#################################################################
//#################################################################
// READ BITE SENSOR FUNCTION:

//void readBite(){
//  biteRead = analogRead(bitePin);
//  biteVal = map(biteRead, 250, 0, 0, 127);
//
//  if(biteVal <= firstHarmonic && biteVal > secondHarmonic){
//    harmonic = 12;
//  }
//  else if(biteVal <= secondHarmonic && biteVal > thirdHarmonic){
//    harmonic = 19;
//  }
//  else if(biteVal <= thirdHarmonic && biteVal > fourthHarmonic){
//    harmonic = 24;
//  }
//  else if(biteVal <= fourthHarmonic && biteVal < fifthHarmonic){
//    harmonic = 28;
//  }
//  else if(biteVal <= fifthHarmonic && biteVal < sixthHarmonic){
//    harmonic = 31;
//  }
//  else if(biteVal <= sixthHarmonic && biteVal < seventhHarmonic){
//    harmonic = 34;
//  }
//  else if(biteVal <= seventhHarmonic){
//    harmonic = 36;
//  }
//}
//      





//#################################################################
//#################################################################
// READ BEND SENSOR FUNCTION:

void readBend(){
  potm = analogRead(bendPin);
  bendTemp = map(potm, 451, 670, 0, 127);
  if(bendTemp != lastBend){
    if(bendTemp != refBend){
      if(bendTemp <= bendLowBuf){
      bendVal = map(bendTemp, 0, bendLowBuf, 0, 60);
      }
      else if(bendTemp >= bendHighBuf){
        bendVal = map(bendTemp, bendHighBuf, 127, 65, 127);
      }
      // bendVal is the output value.
      else if(bendVal < bendHighBuf && bendVal > bendLowBuf){
        bendVal = 64;
      }
    }
  }
      
}




//#################################################################
//#################################################################
// MIDI-Message function:

// sendMidi parameters  for noteOn are: Command, midiNote, midiVelocity
//                      for pitchBend are: Command, lsbBend, msbBend
void sendMidi(int command, int data1, int data2){
  midiSerial.write(command);//send command (noteOn / pitchBend etc)
  midiSerial.write(data1);//send data1 (pitch, lsbBend etc)
  midiSerial.write(data2);//send data2 (velocity, msbBend etc)
}



//#################################################################
//#################################################################
//ROTARY ENCODER UPDATE FUNCTION:
//Called from interrupts on pins 0 and 1.
//encoderOutput is a continuously changing value, counted from 0 at start position.

void rotEncUpdate(){
  int MSB = digitalRead(rotEncPin1); //MSB = most significant bit
  int LSB = digitalRead(rotEncPin2); //LSB = least significant bit

  int encoded = (MSB << 1) | LSB; //converting the 2 pin value to single number
  int sum  = (lastEncoded << 2) | encoded; //adding it to the previous encoded value

  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValue ++;
  if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValue --;


  lastEncoded = encoded;
  encoderOutput = encoderValue / 4; //This encoder shows 4 actual steps in software per physical step.
}




//#################################################################
//#################################################################
// READ THE TOUCH KEYS:

void readKeys(){                      
  byte i;


  for (i = 0; i < NUMKEYS; i++){
    lastPressed[i] = keysPressed[i];
  }

  for (i = 0; i < NUMKEYS; i++){         // Call debounce for touch keys
    keysPressed[i] = debounce(keyPins[i], lastPressed[i], 3);
  }

  byte n = 0;
  for(i = 3; i < NUMKEYS; i++){
    noteKeysPressed[n] = keysPressed[i];
    n++;
  }
//  if(keysPressed[2] == 1 && keysPressed[8] == 1 && keysPressed[3] == 0){
//    refPressure = currentPressure;
//  }
}



//#################################################################
//#################################################################
// DEBOUNCE:
// Debounce function for buttons and keys
boolean debounce(byte pin, boolean last, byte debounceTime){
  boolean current = digitalRead(pin);
  if(last != current){
    delay(debounceTime);
    current = digitalRead(pin);
  }
  return current;
}


//#################################################################
//#################################################################
// PICK A NOTE:
// Compare keysPressed[] from [3] to [12] to known key combinations,
// and set "baseNote" as a note between 46 and 63
void pickNote(){
  int i;
  boolean correct = 0;

  // Test for highEFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 1){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 1){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 63;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for highDNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 1){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 62;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for cSharp:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 61;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for cNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 60;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for bNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 59;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for bFlat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 1){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 58;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for aNat:    
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 57;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for aFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 56;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for gNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 55;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for fSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 54;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for fNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 53;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for eNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 52;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for eFlat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 1){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 51;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for dNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 50;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for lowCSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 49;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for lowCNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 48;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for lowBNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 47;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
  // Test for lowBFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 46;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  //  Serial.println("No note available...");
  //  Serial.println();
  //  delay(20);
}  // End of "void pickNote()"




//#################################################################
//#################################################################
// Octave Update Function:

void setOctave(){
  if(keysPressed[0] == 0 && keysPressed[1] == 0 && keysPressed[2] == 0){
    octave = 46;
  }
  
  else if(keysPressed[0] == 1 && keysPressed[1] == 0 && keysPressed[2] == 0){
    octave = 34;
  }

  else if(keysPressed[0] == 1 && keysPressed[1] == 1 && keysPressed[2] == 0){
    octave = 22;
  }

  else if(keysPressed[0] == 0 && keysPressed[1] == 1 && keysPressed[2] == 0){
    octave = 10;
  }

  else if(keysPressed[0] == 0 && keysPressed[1] == 1 && keysPressed[2] == 1){
    octave = -2;
  }
  
  else if(keysPressed[0] == 0 && keysPressed[1] == 0 && keysPressed[2] == 1){
    octave = -14;
  }
  
  else if(keysPressed[0] == 1 && keysPressed[1] == 1 && keysPressed[2] == 1){
    octave = -26;
  }
}

