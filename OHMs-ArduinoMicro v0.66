
//#####################################################
//#####################################################
// Open Horn Midi system / "OHMs"
// Arduino Micro - Main Code v0.57
// Copyright 2014, Jeppe Tofthøj Rasmussen

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//#####################################################
//#####################################################
#include <EEPROMex.h>
#include <SoftwareSerial.h>
//#include <Wire.h>


//#########################################################
//############# KEY AND NOTE VARIABLES: #################
//Array of all pins with resistive touch switches,
// - In descending fingering order:
byte keyPins[] = {
  A1, A2, A3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
//(octaves)   HD B  A  G  Ab Bb LB  F   E   D   Eb  LC/LBb

// Pin = 14; // MISO pin
// Pin = 15; // SCK pin
#define NUMKEYS sizeof(keyPins)
#define NUMNOTEKEYS 12

//###################################################################
//###########  Fingering-arrays (Key combinations)  ################
byte highEFlat[NUMNOTEKEYS] = {
  1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0};
byte highDNat[NUMNOTEKEYS] = {
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
byte cSharp[NUMNOTEKEYS] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
byte cNat[NUMNOTEKEYS] = {
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
byte bNat[NUMNOTEKEYS] = {
  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
byte bFlat[NUMNOTEKEYS] = {
  0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0};
byte aNat[NUMNOTEKEYS] = {
  0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
byte aFlat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};
byte gNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
byte fSharp[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0};
byte fNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0};
byte eNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0};
byte eFlat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0};
byte dNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0};
byte lowCSharp[NUMNOTEKEYS] = {
  0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1};
byte lowCNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1};
byte lowBNat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0};
byte lowBFlat[NUMNOTEKEYS] = {
  0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1};

// Interval Keys:
//0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0};
  
//Main array which stores the current state of each key pin:
byte keysPressed[NUMKEYS];
// Another array which stores the previous state for comparison:
byte lastPressed[NUMKEYS];
// A shorter version of the original key-array, with the octave key pins removed
byte noteKeysPressed[NUMNOTEKEYS];
// boolean newKeys;


byte baseNote;     
byte currentNote; 
byte lastNote;    
int octave = 0;      
int lastOctave = 0;

//##########################################
//###########  BEND VARIABLES: ############# 
byte bendPin = A5;  // Pin with the bend sensor on it

//pitchbend data storage:
byte lsb = 0;//least siginificant byte of pitchbend message (for 127 step resolution, this stays at 0)
byte bendTemp;
byte bendVal = 64;// (msb) most significant byte of pitchbend message (Bend values from 0 - 127. 64 means no pitchbend)
byte lastBend = 64;
int potm;
// byte bendCenter;
int bendLowBuf = 8;
int bendHighBuf = 8;


//#####################################################################
//##########  FSR VARIABLES (Bite and Breath sensors): ################
byte bitePin = A0; // Pin with the bite sensor on it
int biteRead = 0;
byte biteVal = 0;
byte lastBite = 0;
byte harmonic = 0;

// //harmonic limit constants for bite sensor:
//const byte firstHarmonic = 800;
//const byte secondHarmonic = 500;
//const byte thirdHarmonic = 350;  
//const byte fourthHarmonic = 275;
//const byte fifthHarmonic = 225;
//const byte sixthHarmonic = 190;
//const byte seventhHarmonic = 175;
byte fsrBreathPin = A4; // Pin with the breath sensor on it
int fsrBreathRead;
int fsrBreathMidLow = 240;
int fsrBreathMidHigh = 241;
int fsrBreathTemp;
int fsrBreathCalc;
byte fsrBreathPressure;
byte fsrBreathSaved;
byte velocity; 
byte lastVelocity; // velocity last time through the loop
//int newVelocity = 0;
///////////////////////////////////
//Median filter / Sort variables:
int arraySize = 10;
int breathArray[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


//#####################################################################
//########################   MIDI VARIABLES:  #########################
//MIDI Commands:
byte noteON = 144;
byte pitchBend = 224;
byte continuousController = 176;
byte sostenuto = 66;
byte footController = 4;
byte bankSelect = 0;
byte modulationControl = 1;
boolean sendMessage = 0; // 

//boolean primitiveProtocolOn = 1;
//byte primitiveProtocolCC1 = 11;
//byte primitiveProtocolCC2 = 11;

//Pin = 14; // MISO pin
//Pin = 15; // SCK pin
//Pin = 16; // MOSI pin
////Create a SoftwareSerial instance for sending MIDI commands out.
SoftwareSerial midiSerial(-1, 16);
byte Effect5Depth = 95;
byte Effect2Depth = 92;
// Serial 1-pin LCD setup:
// SoftwareSerial LCDSerial(-1, 16);

//#################################################################
//############  ROTARY ENCODER PINS AND VARIABLES:  ###############
int rotEncPin1 = 1;
int rotEncPin2 = 0;
int rotEncButtonPin = 3;
boolean newValueBool = 0;
int rotEncDir; // Value of 1 or -1
int rotEncLastRead1 = 0;
int rotEncLastRead2 = 0;
boolean currentEncButton;
boolean lastEncButton;
boolean buttonPressed = 0;
boolean buttonReleased = 0;

//#########################################################
//############### MODE VARIABLES: #########################

// "Intervals" Mode global variables:

byte intervalLowBaseNote;
byte intervalLowCurrentNote;
byte intervalLowLastNote;
byte intervalHighBaseNote;
byte intervalHighCurrentNote;
byte intervalHighLastNote;
byte intervalLowPressed; //"bitwrite" variable
byte intervalHighPressed; //"bitwrite" variable
  

//#########################################################
//############### MENU VARIABLES: #########################
SoftwareSerial lcdSerial(-1, 2);
boolean firstTime = 1;
boolean menuOn = 0;
int activeMenu = 0;
int menuItem = 1;
int lastActiveMenu = 0;
int lastMenuItem = 1;
boolean calibrateBreathOn = 0;
boolean calibrateBendOn = 0;

//HARD-CODED FACTORY SETTINGS:
const int breathRangeValueFact = 127; // Full range
const int breathBufferValueFact = 10;
const int breathMinValueFact = 0;
const int breathMaxValueFact = 650;
const int bendPositionValueFact = 2; // Center Position (1 = Low, 2 = Mid, 3 = High)
const int bendBufferValueFact = 10;
const int bendMinValueFact = 447; // Found by testing
const int bendMidValueFact = 540; // Found by testing
const int bendMaxValueFact = 642; // Found by testing
const int pickInstrValueFact = 0;
const int transposeValueFact = 0;
const char modeValueFact = 'N';
const int intervalOctDistFact = 0;

// USER-EDITABLE Settings:
int breathRangeValue;
int breathBufferValue;
int breathMinValue;
int breathMaxValue;
int bendPositionValue;
int bendBufferValue;
int bendMinValue;
int bendMidValue;
int bendMaxValue;
int pickInstrValue;
int transposeValue;
char modeValue; // Modes: 'N' = Normal, 'S' = Sustain, 'I' = Intervals, 'C' = Chords
int intervalOctDist; // Default 0

// MENU ITEM STRINGS:
const char mainMenu[6][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "MAIN MENU: "     }
  , // Menu 0
  {
    "Breath menu ->"     }
  , // On button: go to menu 1
  {
    "Bend menu ->"     }
  , // On button: go to menu 2
  {
    "Playing mode ->"     }
  , // On button: go to menu 3
  {
    "Instrument ->"     }
  , // On button: go to menu 4
  {
    "Exit ->"     } // On button: turn off lcd, menuOn = 0, go back to main loop
};
#define mainMenuSize 6

const char breathMenu[5][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "BREATH MENU: "     }
  , // Menu 1
  {
    "Breath range ->"     }
  , // On button: go to menu 11
  {
    "Breath buffer ->"     }
  , // On button: go to menu 12
  {
    "Breath calibr ->"     }
  , // On button: go to menu 13
  {
    "Exit ->"     } // On button: go to menu 0
};
#define breathMenuSize 5

const char bendMenu[5][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "BEND MENU: "     }
  , // Menu 2
  {
    "Bend Position ->"     }
  , // On button: go to menu 21
  {
    "Bend buffer ->"     }
  , // On button: go to menu 22
  {
    "Bend calibr ->"     }
  , // On button: go to menu 23
  {
    "Exit ->"     } // On button: go to menu 0
};
#define bendMenuSize 5

const char modeMenu[6][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "MODE MENU: "     }
  , // Menu 3
  {
    "Normal ->"     }
  , // On button: go to menu 31
  {
    "Sustain ->"     }
  , // On button: go to menu 32
  {
    "Intervals ->"     }
  , // On button: go to menu 33
  {
    "Chords ->"     }
  , // On button: go to menu 34
  {
    "Exit ->"     } // On button: go to menu 0
};
#define modeMenuSize 6
const char instrumentMenu[7][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "INSTR MENU: "     }
  , // Menu 4
  {
    "Pick instr ->"     }
  , // On button: go to menu 41
  {
    "Transpose ->"     }
  , // On button: go to menu 42
  {
    "Save settings ->"     }
  , // On button: go to menu 43 (Save current settings to EEPROM.)
  {
    "Load Saved ->"     }
  , // On button: go to menu 44 (Set current settings to saved settings.)
  {
    "Load Defaults ->"     }
  , // On button: go to menu 45 (Set current settings to factory settings.)
  {
    "Exit ->"     } // On button: go to menu 0
};
#define instrumentMenuSize 7

const char breathRangeTitle[] =
"BREATH RANGE: "; // Menu 11

const char breathBufferTitle[] =
"BREATH BUFFER: "; // Menu 12

const char breathCalMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "CALIBR. BREATH "     }
  , // Menu 13
  {
    "Calibrate start?"     }
  ,// Wait for button, menuItem = 3;
  {
    "Exit "     }
  ,
  {
    "End calibration?"     } // Read data from breath sensor, Wait for button, go to menu 0 menuItem 1
};
#define breathCalMenuSize 4

const char bendPositionMenu[] =
"BEND POSITION"; // Menu 21

const char bendBufferTitle[] =
"BEND BUFFER: "; // Menu 22

const char bendCalMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "CALIBR. BEND "     }
  ,// Menu 23
  {
    "Calibrate start?"     }
  ,// Wait for button, menuItem = 3;
  {
    "Exit. "     }
  , // Read data from bend sensor, Wait for button, go to menu 0 menuItem 2
  {
    "End calibration?"     }
};
#define bendCalMenuSize 4



const char normalModeMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "NORMAL MODE? "     }
  , // Menu 31
  {
    "No, exit! "     }
  , // On button: go to menu 3 menuItem 1
  {
    "Yes, Normal mode"     }
  , // On buttonpressed == 1: print("Confirmed - Normal mode"
  {
    "Confirmed. "     } // Wait for buttonReleased, set "normal" mode, go to menu 0, menuItem3,
};
#define normalModeMenuSize 4

const char sustainModeMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {    "SUSTAIN MODE? "     }  , // Menu 32
  {    "No, exit! "     }  , // On button: go to menu 3 menuItem 2
  {    "Yes, Sustain. "     }  , // On buttonpressed == 1: print("Confirmed - Sustain mode"
  {    "Confirmed. "     } // Wait for buttonReleased, set "sustain" mode, go to menu 0, menuItem3,
};
#define sustainModeMenuSize 4

const char intervalModeMenu[5][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {    "INTERVAL MODE?  "     }  , // Menu 33
  {    "No, exit!       "     }  , // On button: go to menu 3 menuItem 3
  {    "Yes, Intervals. "     }  , // On buttonpress go to menuItem 3
  {    "OCTAVE DISTANCE:" },       // Second title
  {    "Confirmed.      "     } // Wait for buttonReleased, set "interval" mode, go to menu 0, menuItem3,
};
#define intervalModeMenuSize 5

const char chordModeMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "CHORD MODE? "     }
  , // Menu 34
  {
    "No, exit! "     }
  , // On button: go to menu 3 menuItem 4
  {
    "Yes, Chord mode."     }
  , // On buttonpressed == 1: print("Confirmed - Chord mode"
  {
    "Confirmed. "     } // Wait for buttonReleased, set "chords" mode, go to menu 0, menuItem3,
};
#define chordModeMenuSize 4




const char pickInstrTitle[] =
"PICK INSTRUMENT:"; // Menu 41
const char transposeTitle[] =
"TRANSPOSE: "; // Menu 42
const char saveSetMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "SAVE SETTINGS: "     }
  , // Menu 43
  {
    "Exit. "     }
  , // On button: go to menu 4, menuItem 3
  {
    "Save all. "     }
  ,
  {
    "Confirmed. "     }
};
#define saveSetMenuSize 4
const char loadSavedSetMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "LOAD SETTINGS "     }
  , // Menu 44
  {
    "Exit. "     }
  , // On button: go to menu 4, menuItem 4
  {
    "Load all. "     }
  ,
  {
    "Confirmed. "     }
};
#define loadSavedSetMenuSize 4
const char loadFactSetMenu[4][17] = { // [NUMBER OF ELEMENTS] [MAX_SIZE]
  {
    "RESTORE DEFAULT:"     }
  , // Menu 45
  {
    "Exit. "     }
  , // On button: go to menu 4, menuItem 5
  {
    "Restore all. "     }
  ,
  {
    "Confirmed. "     }
};
#define loadFactSetMenuSize 4



//#####################################################################
//#########################    SETUP:    ############################## 
void setup(){
  delay(1000);
  byte i;
  for (i=0; i < NUMKEYS; i++){
    pinMode(keyPins[i], INPUT);
    digitalWrite(keyPins[i], HIGH);
  }
  // ROTARY ENCODER SETUP:
  pinMode(rotEncPin1, INPUT);
  pinMode(rotEncPin2, INPUT);
  pinMode(rotEncButtonPin, INPUT);
  digitalWrite(rotEncPin1, HIGH); //turn pullup resistor on
  digitalWrite(rotEncPin2, HIGH); //turn pullup resistor on
  digitalWrite(rotEncButtonPin, HIGH); //turn pullup resistor on

//  Serial.begin(9600); // Debug Serial
  midiSerial.begin(31250);
  lcdSerial.begin(9600);

  // Welcome screen + "loading settings" screen
  lcdOn();
  lcdTextLine0(" Open Horn ");
  lcdTextLine1(" MIDI system ");
  //###################################################
  // RETRIEVE SETTINGS FROM HARDWIRED DEFAULTS:
  restoreFactorySettings();
  delay(2000);
  //#########################
  // UPDATE SETTINGS FROM EEPROM:
  lcdTextLine0(" Loading ");
  lcdTextLine1(" user settings. ");
  loadAllSettings();
  delay(2000);
  lcdOff();
}


//#################################################################
//#################################################################
//########################    MAIN LOOP:    #######################
void loop(){
  encButtonRead();
  if(menuOn == 0 && buttonPressed == 1){
    while(buttonReleased == 0){
      delay(10);
      encButtonRead();
    }
    menuOn = 1;
    newValueBool = 0;
    firstTime = 1;
    updateMenu();
  }

  int n;
  byte i;
  // timer1 = millis(); // Update timer1, to keep track of the pressure sensor wait time
  //
  updatePressure(); // Updates pressure and velocity values
  if(velocity != lastVelocity){
    sendMessage = 1;
  }
  readKeys(); 

// SPLIT HERE INTO DIFFERENT MODES:


  /////////////////////////////////////////////////
  //// Debug for "readKeys()" only:
  // for (i = 0; i < NUMKEYS; i++){
  // Serial.print(keysPressed[i]);
  // }
  // Serial.println();
  //// End debug /////////////////////////////////


  
  if(modeValue == 'I' && noteKeysPressed[0] == 1){
    pickInterval();
    setOctave();
    intervalHighCurrentNote = intervalHighBaseNote + octave;
    intervalLowCurrentNote = intervalLowBaseNote + octave;
    if(intervalHighCurrentNote != intervalHighLastNote || intervalLowCurrentNote != intervalLowLastNote){
      sendMessage = 1;
    }
  }  
  
    
  else if(modeValue == 'N' || noteKeysPressed[0] == 0){
    pickNote();
    setOctave(); 
    currentNote = baseNote + octave; 
    if(currentNote != lastNote){ 
      sendMessage = 1; 
    }
  }


  readBend(); // Updates the bend value from the neck sensor and maps it to 0 - 127.
  if(bendVal != lastBend){
    sendMessage = 1;
  }
  // readBite();
  // if(biteVal != lastBite){
  // sendMessage = 1;
  // }

//####################################################################
//######################   MIDI MESSAGE SECTION:  ###################

  if(sendMessage == 1){

//Interval Midi Message section:
    if(modeValue == 'I' && noteKeysPressed[0] == 1){
      if(lastPressed[3] == 0){
        sendMidi(noteON, currentNote, 0);
        sendMidi(noteON, lastNote, 0);
      }

      if(intervalHighCurrentNote != intervalHighLastNote || intervalLowCurrentNote != intervalLowLastNote){
  // Turn off old notes where needed:
        if(intervalHighCurrentNote != intervalHighLastNote){
          if(intervalHighLastNote != intervalLowCurrentNote){
            sendMidi(noteON, intervalHighLastNote, 0);
          }     
          if(intervalHighPressed != 0){
            sendMidi(noteON, intervalHighCurrentNote, velocity);
          }
        }
        if(intervalLowCurrentNote != intervalLowLastNote){
          if(intervalLowLastNote != intervalHighCurrentNote){
            sendMidi(noteON, intervalLowLastNote, 0);
          }
          if(intervalLowPressed != 0){
            sendMidi(noteON, intervalLowCurrentNote, velocity); 
          }
        }
  // Turn on new notes where needed:        

      }
     
// Interval general Midi messages:
      if(velocity == 0){
        sendMidi(noteON, intervalHighCurrentNote, 0);
        sendMidi(noteON, intervalHighLastNote, 0);
        sendMidi(noteON, intervalLowCurrentNote, 0);
        sendMidi(noteON, intervalLowLastNote, 0);
      }

      else if(velocity != lastVelocity){
        if(lastVelocity != 0){
          sendMidi(continuousController, 2, velocity);       
        }
        else if(lastVelocity == 0){
          sendMidi(noteON, intervalHighCurrentNote, velocity);
          sendMidi(noteON, intervalLowCurrentNote, velocity);
        }
      }

    }
    else if(modeValue == 'I' && lastPressed[3] == 1){
      sendMidi(noteON, intervalHighCurrentNote, 0);
      sendMidi(noteON, intervalHighLastNote, 0);
      sendMidi(noteON, intervalLowCurrentNote, 0);
      sendMidi(noteON, intervalLowLastNote, 0);
    }    
//Interval Midi section END:


// "Normal mode" Midi messages:
    else if(modeValue == 'N' || noteKeysPressed[0] == 0){
      if(currentNote != lastNote){
        sendMidi(noteON, currentNote, velocity);
        sendMidi(noteON, lastNote, 0);
      }
      else if(velocity != lastVelocity){
        if(velocity != 0 && lastVelocity == 0){
          sendMidi(noteON, currentNote, velocity);
        }
        else{
          sendMidi(continuousController, 2, velocity);
        }
      }
      if(velocity == 0){
        sendMidi(noteON, currentNote, 0);
        sendMidi(noteON, lastNote, 0);
      }
    }

// General Midi messages:    
    if(bendVal != lastBend){
      sendMidi(pitchBend, 0, bendVal);
    }
    // if(biteVal != lastBite){
    // sendMidi(modulationControl, 0, biteVal);
    // lastBite = biteVal;
    // }
    
    fsrBreathSaved = fsrBreathPressure;
    lastVelocity = velocity;
    lastNote = currentNote;
    intervalHighLastNote = intervalHighCurrentNote;
    intervalLowLastNote = intervalLowCurrentNote;
    lastBend = bendVal;

//    MAIN DEBUG:
//    if(sendMessage == 1){
//      Serial.println();
//      Serial.print("Reference pressure: ");
//      Serial.println(refPressure);
//      Serial.print("Current pressure: ");
//      Serial.println(currentPressure);
//      Serial.print("Velocity: ");
//      Serial.println(velocity);
//      if(modeValue == 'I' && noteKeysPressed[0] == 1){
//        Serial.print("Interval High Note: ");
//        Serial.println(intervalHighCurrentNote);
//        Serial.print("Interval Low Note: ");
//        Serial.println(intervalLowCurrentNote);
//      }
//      else{
//        Serial.print("Current Note: ");
//        Serial.println(currentNote);
//      }

//      Serial.print("Note bend value: ");
//      Serial.println(bendVal);
//      Serial.print("Rotary encoder position: ");
//      Serial.println(encoderOutput);
//      delay(20);
//    }
    sendMessage = 0;
  }
} // End of main loop






//#################################################################
//#################################################################
//######################### FUNCTIONS: ############################
//#################################################################
//#################################################################

// READ BITE SENSOR FUNCTION:
//void readBite(){
//  biteRead = analogRead(bitePin);
//  biteVal = map(biteRead, 250, 0, 0, 127);
//
//  if(biteVal <= firstHarmonic && biteVal > secondHarmonic){
//  harmonic = 12;
//  }
//  else if(biteVal <= secondHarmonic && biteVal > thirdHarmonic){
//  harmonic = 19;
//  }
//  else if(biteVal <= thirdHarmonic && biteVal > fourthHarmonic){
//  harmonic = 24;
//  }
//  else if(biteVal <= fourthHarmonic && biteVal < fifthHarmonic){
//  harmonic = 28;
//  }
//  else if(biteVal <= fifthHarmonic && biteVal < sixthHarmonic){
//  harmonic = 31;
//  }
//  else if(biteVal <= sixthHarmonic && biteVal < seventhHarmonic){
//  harmonic = 34;
//  }
//  else if(biteVal <= seventhHarmonic){
//  harmonic = 36;
//  }
//}


//###################################################################
//############ FSR Breath pressure function - Sets velocity:
void updatePressure(){
  int i;
  for(i = 0; i < arraySize; i++){
    fsrBreathTemp = analogRead(fsrBreathPin);
    breathArray[i] = fsrBreathTemp;
  }
  isort(breathArray,arraySize);
  fsrBreathRead = breathArray[arraySize / 2];
  fsrBreathRead = map(fsrBreathRead, 1023, 0, 0, 1023); // Reverse the input
  int breathLowBuf = breathMinValue + breathBufferValue; // combine minValue and bufferValue for final buffer...
  if(fsrBreathRead < breathLowBuf){
    fsrBreathPressure = 0;
  }
  else{
    if(fsrBreathRead <= breathMaxValue){
      fsrBreathPressure = map(fsrBreathRead, breathLowBuf, breathMaxValue, 1, 127);
    }
    else if(fsrBreathRead > breathMaxValue){
      fsrBreathPressure = 127;
    }
  }
  if(fsrBreathPressure != fsrBreathSaved){
    velocity = fsrBreathPressure;
    fsrBreathSaved = fsrBreathPressure;
  }
}


void calibrateBreath(){
  int i;
  for(i = 0; i < arraySize; i++){
    fsrBreathTemp = analogRead(fsrBreathPin);
    breathArray[i] = fsrBreathTemp;
  }
  isort(breathArray,arraySize);
  fsrBreathRead = breathArray[arraySize / 2];
  fsrBreathRead = map(fsrBreathRead, 1023, 0, 0, 1023);
  if(fsrBreathRead > breathMaxValue){
    breathMaxValue = fsrBreathRead;
  }
  if(fsrBreathRead < breathMinValue){
    breathMinValue = fsrBreathRead;
  }
}


//#################################################################
//#################################################################
// READ BEND SENSOR FUNCTION:
void readBend(){
  potm = analogRead(bendPin);
  bendLowBuf = bendMidValue - bendBufferValue;
  bendHighBuf = bendMidValue + bendBufferValue;
  if(potm <= bendLowBuf){
    bendTemp = map(potm, bendMinValue, bendLowBuf, 0, 63);
    if(bendTemp != lastBend){
      bendVal = bendTemp;
    }
  }
  else if(potm >= bendHighBuf){
    bendTemp = map(potm, bendHighBuf, bendMaxValue, 65, 127);
    if(bendTemp != lastBend){
      bendVal = bendTemp;
    }
  }
  // bendVal is the output value.
  else if(potm > bendLowBuf && potm < bendHighBuf ){
    bendVal = 64;
  }
}
//#################################################################
//#################################################################
// CALIBRATE BEND SENSOR FUNCTION:
void calibrateBend(){
  potm = analogRead(bendPin);
  if(potm > bendMaxValue){
    bendMaxValue = potm;
  }
  if(potm < bendMinValue){
    bendMinValue = potm;
  }
}

//#################################################################
//#################################################################
// READ THE TOUCH KEYS:
void readKeys(){
  byte i;
  for (i = 0; i < NUMKEYS; i++){
    lastPressed[i] = keysPressed[i];
  }
  for (i = 0; i < NUMKEYS; i++){ // Call debounce for touch keys
    keysPressed[i] = debounce(keyPins[i], lastPressed[i], 2); // Original debounceTime = 8
  }
  
}


//#################################################################
//#################################################################
// MIDI-Message function:
// sendMidi parameters for noteOn are: Command, midiNote, midiVelocity
// for pitchBend are: Command, lsbBend, msbBend
void sendMidi(int command, int data1, int data2){
  midiSerial.write(command);//send command (noteOn / pitchBend etc)
  midiSerial.write(data1);//send data1 (pitch, lsbBend etc)
  midiSerial.write(data2);//send data2 (velocity, msbBend etc)
}

//#################################################################
//######### Read encoder: ####################################
void rotEncRead(){
  int m;
  rotEncDir = 0;
  int n = debounce(rotEncPin1, rotEncLastRead1, 1);
  if((rotEncLastRead1 == LOW) && (n == HIGH)){
    m = debounce(rotEncPin2, rotEncLastRead2, 1);
    if(m == LOW){
      rotEncDir = -1;
    }
    else{
      rotEncDir = 1;
    }
    newValueBool = 1;
  }
  rotEncLastRead1 = n;
  rotEncLastRead2 = m;
}

//#################################################################
//######### Read encoder button: ############################
void encButtonRead(){
  currentEncButton = debounce(rotEncButtonPin, lastEncButton, 2);
  if(currentEncButton == 1 && lastEncButton == 0){
    buttonPressed = 0;
    buttonReleased = 1;
  }
  else if(currentEncButton == 0 && lastEncButton == 1){
    buttonReleased = 0;
    buttonPressed = 1;
  }
  else{
    buttonPressed = 0;
    buttonReleased = 0;
  }
  lastEncButton = currentEncButton;
}


//#################################################################
//##################    PICK INTERVAL:    #########################

void pickInterval(){
  int i;
  byte n = 0;
  for(i = 7; i > 3; i--){
    bitWrite(intervalHighPressed, n, keysPressed[i]);
    n++;
  }
  
  n = 0;
  for(i = 13; i > 9; i--){
    bitWrite(intervalLowPressed, n, keysPressed[i]);
    n++;
  }
  if(intervalHighPressed != 0){
    intervalHighBaseNote = 47 + intervalOctDist + intervalHighPressed;
  }
  if(intervalLowPressed != 0){
    intervalLowBaseNote = 47 + intervalLowPressed;// "0000" is used as an "empty", to turn off the note. 
  }       //So "0001"(= decimal 1) means C (Midi note "59 + 1" = 60).  
  if(intervalHighPressed == 0){
    intervalHighBaseNote = intervalLowBaseNote;
  }
  if(intervalLowPressed == 0){
    intervalLowBaseNote = intervalHighBaseNote;
  }
  noteKeysPressed[0] = keysPressed[3];
// This is the "high D" key, used for turning interval mode on and off on the fly.

}



//#################################################################
//###################     PICK A NOTE:    ##########################

void pickNote(){
  int i;
  byte n = 0;
  for(i = 3; i < NUMKEYS; i++){
    noteKeysPressed[n] = keysPressed[i];
    n++;
  }  

  boolean correct = 0;
  // Test for highEFlat:
  if(modeValue == 'N'){
    if(correct == 0){
      if(noteKeysPressed[0] == 1){
        if(noteKeysPressed[1] == 0){
          if(noteKeysPressed[2] == 0){
            if(noteKeysPressed[3] == 0){
              if(noteKeysPressed[4] == 0){
                if(noteKeysPressed[5] == 1){
                  if(noteKeysPressed[6] == 0){
                    if(noteKeysPressed[7] == 0){
                      if(noteKeysPressed[8] == 0){
                        if(noteKeysPressed[9] == 0){
                          if(noteKeysPressed[10] == 0){
                            if(noteKeysPressed[11] == 0){
                              baseNote = 63;
                              correct = 1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    // Test for highDNat:
    if(correct == 0){
      if(noteKeysPressed[0] == 1){
        if(noteKeysPressed[1] == 0){
          if(noteKeysPressed[2] == 0){
            if(noteKeysPressed[3] == 0){
              if(noteKeysPressed[4] == 0){
                if(noteKeysPressed[5] == 0){
                  if(noteKeysPressed[6] == 0){
                    if(noteKeysPressed[7] == 0){
                      if(noteKeysPressed[8] == 0){
                        if(noteKeysPressed[9] == 0){
                          if(noteKeysPressed[10] == 0){
                            if(noteKeysPressed[11] == 0){
                              baseNote = 62;
                              correct = 1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for cSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 61;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for cNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 60;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for bNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 59;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for bFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 1){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 58;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for aNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 57;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for aFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 56;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for gNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 55;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for fSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 54;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for fNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 53;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for eNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 52;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for eFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 1){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 51;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for dNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 50;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for lowCSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 49;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for lowCNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 48;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for lowBNat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 47;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Test for lowBFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 46;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // Serial.println("No note available...");
  // Serial.println();
  // delay(20);
} // End of "void pickNote()"



//#################################################################
//#################    Octave Update Function:    #################
void setOctave(){
  if(keysPressed[0] == 0 && keysPressed[1] == 0 && keysPressed[2] == 0){
    octave = 48;
  }
  else if(keysPressed[0] == 1 && keysPressed[1] == 0 && keysPressed[2] == 0){
    octave = 36;
  }
  else if(keysPressed[0] == 1 && keysPressed[1] == 1 && keysPressed[2] == 0){
    octave = 24;
  }
  else if(keysPressed[0] == 0 && keysPressed[1] == 1 && keysPressed[2] == 0){
    octave = 12;
  }
  else if(keysPressed[0] == 0 && keysPressed[1] == 1 && keysPressed[2] == 1){
    octave = 0;
  }
  else if(keysPressed[0] == 0 && keysPressed[1] == 0 && keysPressed[2] == 1){
    octave = -12;
  }
  else{ // All octave keys pressed
    octave = -24;
  }
  octave = octave + transposeValue; // Transpose operation from menu settings
}



//##################################################
//########     LCD MESSAGE FUNCTIONS:     ##########
void lcdTextLine0(const char* inputString){
  lcdSerial.print('#');
  lcdSerial.print(inputString);
  lcdSerial.print('\n');
  // Serial.println(inputString);
}
void lcdTextLine1(const char* inputString){
  lcdSerial.print('$');
  lcdSerial.print(inputString);
  lcdSerial.print('\n');
  // Serial.print(" ");
  // Serial.println(inputString);
}
void lcdInt1Line1(int input){
  lcdSerial.print('%');
  lcdSerial.print(input);
  lcdSerial.print('\n');
  // Serial.print(" ");
  // Serial.println(input);
}
void lcdInt2Line1(int input){
  lcdSerial.print('*');
  lcdSerial.print(input);
  lcdSerial.print('\n');
  // Serial.print(" ");
  // Serial.println(input);
}
void lcdOn(){
  lcdSerial.print('[');
  // Serial.println("lcdOn");
}
void lcdOff(){
  lcdSerial.print(']');
  // Serial.println("lcdOff");
}


//########################################################
//###########    MAIN MENU FUNCTION:   ###################
void updateMenu(){
  while(1){
    if(firstTime == 1){    // Entering menu for the first time
      lcdOn();
      activeMenu = 0;
      lcdTextLine0(mainMenu[0]);
      menuItem = 1;
      lcdTextLine1(mainMenu[menuItem]);
    }
    // First time end.
    
    // Read input:
    if(firstTime == 0){
      rotEncRead();
      encButtonRead();
    }
    firstTime = 0;
    // Read encoder input end. Turn "firstTime" off
    
    if(calibrateBreathOn == 1){
      calibrateBreath();
    }
    if(calibrateBendOn == 1){
      calibrateBend();
    }
    //////////////////
    // ON NEW ENCODER INPUT:
    if(newValueBool == 1 && firstTime == 0){
      if(activeMenu == 0){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = mainMenuSize - 1;
        }
        else if(menuItem > mainMenuSize - 1){
          menuItem = 1;
        }
        lcdTextLine1(mainMenu[menuItem]);
      }
      else if(activeMenu == 1){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = breathMenuSize - 1;
        }
        else if(menuItem > breathMenuSize - 1){
          menuItem = 1;
        }
        lcdTextLine1(breathMenu[menuItem]);
      }
      else if(activeMenu == 2){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = bendMenuSize - 1;
        }
        else if(menuItem > bendMenuSize - 1){
          menuItem = 1;
        }
        lcdTextLine1(bendMenu[menuItem]);
      }
      else if(activeMenu == 3){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = modeMenuSize - 1;
        }
        else if(menuItem > modeMenuSize - 1){
          menuItem = 1;
        }
        lcdTextLine1(modeMenu[menuItem]);
      }
      else if(activeMenu == 4){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = instrumentMenuSize - 1;
        }
        else if(menuItem > instrumentMenuSize - 1){
          menuItem = 1;
        }
        lcdTextLine1(instrumentMenu[menuItem]);
      }
      else if(activeMenu == 11){
        breathRangeValue += rotEncDir;
        if(breathRangeValue < 0){
          breathRangeValue = 0;
        }
        if(breathRangeValue > 127){
          breathRangeValue = 127;
        }
        lcdInt1Line1(breathRangeValue);
      }
      else if(activeMenu == 12){
        breathBufferValue += rotEncDir;
        if(breathBufferValue < 0){
          breathBufferValue = 0;
        }
        if(breathBufferValue > 50){
          breathBufferValue = 50;
        }
        lcdInt1Line1(breathBufferValue);
      }
      else if(activeMenu == 13){
        if(menuItem == 1){
          menuItem = 2;
          lcdTextLine1(breathCalMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 1;
          lcdTextLine1(breathCalMenu[menuItem]);
        }
      }
      else if(activeMenu == 21){
        bendPositionValue += rotEncDir;
        if(bendPositionValue < 0){
          bendPositionValue = 0;
        }
        if(bendPositionValue > 127){
          bendPositionValue = 127;
        }
        lcdInt1Line1(bendPositionValue);
      }
      else if(activeMenu == 22){
        bendBufferValue += rotEncDir;
        if(bendBufferValue < 0){
          bendBufferValue = 0;
        }
        if(bendBufferValue > 50){
          bendBufferValue = 50;
        }
        lcdInt1Line1(bendBufferValue);
      }
      else if(activeMenu == 23){
        if(menuItem == 1){
          menuItem = 2;
          lcdTextLine1(bendCalMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 1;
          lcdTextLine1(bendCalMenu[menuItem]);
        }
      }
      else if(activeMenu == 31){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = normalModeMenuSize - 2;
        }
        else if(menuItem > normalModeMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(normalModeMenu[menuItem]);
      }
      else if(activeMenu == 32){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = sustainModeMenuSize - 2;
        }
        else if(menuItem > sustainModeMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(sustainModeMenu[menuItem]);
      }
      
      
      else if(activeMenu == 33){
        if(menuItem < 3){
          menuItem += rotEncDir; //
          if(menuItem < 1){
            menuItem = intervalModeMenuSize - 2;
          }
          else if(menuItem > intervalModeMenuSize - 2){
            menuItem = 1;
          }
          lcdTextLine1(intervalModeMenu[menuItem]);
        }
        else if(menuItem == 3){
          intervalOctDist += rotEncDir;
          lcdInt1Line1(intervalOctDist);
        }
      }
      
      
      else if(activeMenu == 34){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = chordModeMenuSize - 2;
        }
        else if(menuItem > chordModeMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(chordModeMenu[menuItem]);
      }
      else if(activeMenu == 41){
        pickInstrValue += rotEncDir;
        if(pickInstrValue < 0){
          pickInstrValue = 0;
        }
        if(pickInstrValue > 127){
          pickInstrValue = 127;
        }
        lcdInt1Line1(pickInstrValue);
      }
      else if(activeMenu == 42){
        transposeValue += rotEncDir;
        if(transposeValue < -12){
          transposeValue = -12;
        }
        if(transposeValue > 12){
          transposeValue = 12;
        }
        lcdInt1Line1(transposeValue);
      }
      else if(activeMenu == 43){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = saveSetMenuSize - 2;
        }
        else if(menuItem > saveSetMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(saveSetMenu[menuItem]);
      }
      else if(activeMenu == 44){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = loadSavedSetMenuSize - 2;
        }
        else if(menuItem > loadSavedSetMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(loadSavedSetMenu[menuItem]);
      }
      else if(activeMenu == 45){
        menuItem += rotEncDir; //
        if(menuItem < 1){
          menuItem = loadFactSetMenuSize - 2;
        }
        else if(menuItem > loadFactSetMenuSize - 2){
          menuItem = 1;
        }
        lcdTextLine1(loadFactSetMenu[menuItem]);
      }
    }
    newValueBool = 0;
    firstTime = 0;
    ////////////////////
    // ON BUTTON PRESS:
    if(buttonPressed == 1){

      //#############################################################
      //#### MAIN MENU BUTTON SECTION:
      if(activeMenu == 0){
        if(menuItem == 1){
          activeMenu = menuItem;
          lcdTextLine0(breathMenu[0]);
          lcdTextLine1(breathMenu[1]);
        }
        else if(menuItem == 2){
          activeMenu = menuItem;
          menuItem = 1;
          lcdTextLine0(bendMenu[0]);
          lcdTextLine1(bendMenu[1]);
        }
        else if(menuItem == 3){
          activeMenu = menuItem;
          menuItem = 1;
          lcdTextLine0(modeMenu[0]);
          lcdTextLine1(modeMenu[1]);
        }
        else if(menuItem == 4){
          activeMenu = menuItem;
          menuItem = 1;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[1]);
        }
        else if(menuItem == 5){
          lcdOff();
          menuOn = 0;
          firstTime = 1;
          return;
        }
      }
      //#############################################################
      //#### BREATH MENU BUTTON SECTION:
      else if(activeMenu == 1){
        if(menuItem == 1){
          activeMenu = 11;
          lcdTextLine0(breathRangeTitle);
          lcdInt1Line1(breathRangeValue);
        }
        else if(menuItem == 2){
          activeMenu = 12;
          menuItem = 1;
          lcdTextLine0(breathBufferTitle);
          lcdInt1Line1(breathBufferValue);
        }
        else if(menuItem == 3){
          activeMenu = 13;
          menuItem = 1;
          lcdTextLine0(breathCalMenu[0]);
          lcdTextLine1(breathCalMenu[menuItem]);
        }
        else if(menuItem == 4){
          activeMenu = 0;
          menuItem = 1;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### BEND MENU BUTTON SECTION:
      else if(activeMenu == 2){
        if(menuItem == 1){
          activeMenu = 21;
          lcdTextLine0(bendPositionMenu);
          lcdInt1Line1(bendPositionValue);
        }
        else if(menuItem == 2){
          activeMenu = 22;
          menuItem = 1;
          lcdTextLine0(bendBufferTitle);
          lcdInt1Line1(bendBufferValue);
        }
        else if(menuItem == 3){
          activeMenu = 23;
          menuItem = 1;
          lcdTextLine0(bendCalMenu[0]);
          lcdTextLine1(bendCalMenu[menuItem]);
        }
        else if(menuItem == 4){
          activeMenu = 0;
          menuItem = 1;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### MODE MENU BUTTON SECTION:
      else if(activeMenu == 3){
        if(menuItem == 1){
          activeMenu = 31;
          lcdTextLine0(normalModeMenu[0]);
          lcdTextLine1(normalModeMenu[menuItem]);
        }
        else if(menuItem == 2){
          activeMenu = 32;
          menuItem = 1;
          lcdTextLine0(sustainModeMenu[0]);
          lcdTextLine1(sustainModeMenu[menuItem]);
        }
        else if(menuItem == 3){
          activeMenu = 33;
          if(modeValue != 'I'){
            menuItem = 1;
            lcdTextLine0(intervalModeMenu[0]);
            lcdTextLine1(intervalModeMenu[menuItem]);
          }
          else{
            menuItem = 3;
            lcdTextLine0(intervalModeMenu[3]);
            lcdInt1Line1(intervalOctDist);
          }
        }
        else if(menuItem == 4){
          activeMenu = 34;
          menuItem = 1;
          lcdTextLine0(chordModeMenu[0]);
          lcdTextLine1(chordModeMenu[menuItem]);
        }
        else if(menuItem == 5){
          activeMenu = 0;
          menuItem = 1;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### INSTRUMENT MENU BUTTON SECTION:
      else if(activeMenu == 4){
        if(menuItem == 1){
          activeMenu = 41;
          lcdTextLine0(pickInstrTitle);
          lcdInt1Line1(pickInstrValue);
        }
        else if(menuItem == 2){
          activeMenu = 42;
          menuItem = 1;
          lcdTextLine0(transposeTitle);
          lcdInt1Line1(transposeValue);
        }
        else if(menuItem == 3){
          activeMenu = 43;
          menuItem = 1;
          lcdTextLine0(saveSetMenu[0]);
          lcdTextLine1(saveSetMenu[menuItem]);
        }
        else if(menuItem == 4){
          activeMenu = 44;
          menuItem = 1;
          lcdTextLine0(loadSavedSetMenu[0]);
          lcdTextLine1(loadSavedSetMenu[menuItem]);
        }
        else if(menuItem == 5){
          activeMenu = 45;
          menuItem = 1;
          lcdTextLine0(loadFactSetMenu[0]);
          lcdTextLine1(loadFactSetMenu[menuItem]);
        }
        else if(menuItem == 6){
          activeMenu = 0;
          menuItem = 4;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### BREATH RANGE MENU BUTTON SECTION:
      else if(activeMenu == 11){
        activeMenu = 1;
        menuItem = 1;
        lcdTextLine0(breathMenu[0]);
        lcdTextLine1(breathMenu[menuItem]);
      }
      //#############################################################
      //#### BREATH BUFFER MENU BUTTON SECTION:
      else if(activeMenu == 12){
        activeMenu = 1;
        menuItem = 2;
        lcdTextLine0(breathMenu[0]);
        lcdTextLine1(breathMenu[menuItem]);
      }
      //#############################################################
      //#### BREATH CALIBRATION MENU BUTTON SECTION:
      else if(activeMenu == 13){
        if(menuItem == 1){
          menuItem = 3;
          breathMinValue = 1023;
          breathMaxValue = 0;
          calibrateBreathOn = 1;
          lcdTextLine1(breathCalMenu[menuItem]);
        }
        else if(menuItem == 2){
          activeMenu = 1;
          menuItem = 3;
          lcdTextLine0(breathMenu[0]);
          lcdTextLine1(breathMenu[menuItem]);
        }
        else if(menuItem == 3){
          activeMenu = 0;
          menuItem = 1;
          calibrateBreathOn = 0;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### BEND POSITION MENU BUTTON SECTION:
      else if(activeMenu == 21){
        activeMenu = 2;
        menuItem = 1;
        lcdTextLine0(bendMenu[0]);
        lcdTextLine1(bendMenu[menuItem]);
      }
      
      
      
      
      //#############################################################
      //#### BEND BUFFER MENU BUTTON SECTION:
      else if(activeMenu == 22){
        activeMenu = 2;
        menuItem = 2;
        lcdTextLine0(bendMenu[0]);
        lcdTextLine1(bendMenu[menuItem]);
      }
      //#############################################################
      //#### BEND CALIBRATION MENU BUTTON SECTION:
      else if(activeMenu == 23){
        if(menuItem == 1){
          menuItem = 3;
          potm = analogRead(bendPin);
          bendMidValue = potm;
          calibrateBendOn = 1; // START CALIBRATION
          bendMinValue = 1023;
          bendMaxValue = 0;
          lcdTextLine1(bendCalMenu[menuItem]);
        }
        else if(menuItem == 2){
          activeMenu = 2;
          menuItem = 3;
          lcdTextLine0(bendMenu[0]);
          lcdTextLine1(bendMenu[menuItem]);
        }
        else if(menuItem == 3){
          activeMenu = 0;
          menuItem = 2;
          potm = analogRead(bendPin);
          bendMidValue = (bendMidValue + potm) / 2;
          Serial.println(bendMidValue);
          calibrateBendOn = 0; // END CALIBRATION
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      //#############################################################
      //#### MODE MENU BUTTON SECTION:
      else if(activeMenu == 31){
        if(menuItem == 1){
          activeMenu = 3;
          lcdTextLine0(modeMenu[0]);
          lcdTextLine1(modeMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          modeValue = 'N'; // 'N' == Normal mode
          lcdTextLine1(normalModeMenu[menuItem]);
        }
      }
      else if(activeMenu == 32){
        if(menuItem == 1){
          activeMenu = 3;
          lcdTextLine0(modeMenu[0]);
          lcdTextLine1(modeMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          modeValue = 'S'; // 'S' == Sustain mode
          lcdTextLine1(sustainModeMenu[menuItem]);
        }
      }
      
      else if(activeMenu == 33){
        if(menuItem == 1){
          activeMenu = 3;
          lcdTextLine0(modeMenu[0]);
          lcdTextLine1(modeMenu[menuItem]);
        }        
        else if(menuItem == 2){
          menuItem = 3;
          modeValue = 'I'; // 'I' == Interval mode
          lcdTextLine0(intervalModeMenu[3]);
          lcdInt1Line1(intervalOctDist);
        }
        else if(menuItem == 3){
          menuItem = 4;
          lcdTextLine1(intervalModeMenu[menuItem]);
        }
      }
          
        

      else if(activeMenu == 34){
        if(menuItem == 1){
          activeMenu = 3;
          lcdTextLine0(modeMenu[0]);
          lcdTextLine1(modeMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          modeValue = 'C'; // 'C' == Chords mode
          lcdTextLine1(chordModeMenu[menuItem]);
        }
      }

      //#############################################################
      //#### PICK INSTRUMENT MENU BUTTON SECTION:
      else if(activeMenu == 41){
        activeMenu = 4;
        menuItem = 1;
        lcdTextLine0(instrumentMenu[0]);
        lcdTextLine1(instrumentMenu[menuItem]);
      }
      //#############################################################
      //#### Transpose MENU BUTTON SECTION:
      else if(activeMenu == 42){
        activeMenu = 4;
        menuItem = 2;
        lcdTextLine0(instrumentMenu[0]);
        lcdTextLine1(instrumentMenu[menuItem]);
      }
      //#############################################################
      //#### SAVE SETTINGS MENU BUTTON SECTION:
      else if(activeMenu == 43){
        if(menuItem == 1){
          activeMenu = 4;
          menuItem = 3;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          lcdTextLine1(saveSetMenu[menuItem]); // Show generic "confirmed" message, wait for button release.
          saveAllSettings();
        }
      }
      //#############################################################
      //#### LOAD SETTINGS MENU BUTTON SECTION:
      else if(activeMenu == 44){
        if(menuItem == 1){
          activeMenu = 4;
          menuItem = 4;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          lcdTextLine1(loadSavedSetMenu[menuItem]); // Show generic "confirmed" message, wait for button release.
          loadAllSettings();
        }
      }
      //#############################################################
      //#### RESTORE FACTORY SETTINGS MENU BUTTON SECTION:
      else if(activeMenu == 45){
        if(menuItem == 1){
          activeMenu = 4;
          menuItem = 5;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
        else if(menuItem == 2){
          menuItem = 3;
          lcdTextLine1(loadFactSetMenu[menuItem]); // Show generic "confirmed" message, wait for button release.
          restoreFactorySettings();
        }
      }
    } // if(buttonPressed == 1) end
    buttonPressed = 0;



    //#############################################################
    // ON BUTTON RELEASE: 
    if(buttonReleased == 1){
      //#############################################################
      //#### MODE MENU BUTTON release SECTION:
      if(activeMenu == 31){
        if(menuItem == 3){
          activeMenu = 0;
          menuItem = 3;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      if(activeMenu == 32){
        if(menuItem == 3){
          activeMenu = 0;
          menuItem = 3;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      if(activeMenu == 33){
        if(menuItem == 4){
          activeMenu = 0;
          menuItem = 3;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      if(activeMenu == 34){
        if(menuItem == 3){
          activeMenu = 0;
          menuItem = 3;
          lcdTextLine0(mainMenu[0]);
          lcdTextLine1(mainMenu[menuItem]);
        }
      }
      
      
      if(activeMenu == 43){
        if(menuItem == 3){
          activeMenu = 4;
          menuItem = 3;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
      }
      if(activeMenu == 44){
        if(menuItem == 3){
          activeMenu = 4;
          menuItem = 4;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
      }
      if(activeMenu == 45){
        if(menuItem == 3){
          activeMenu = 4;
          menuItem = 5;
          lcdTextLine0(instrumentMenu[0]);
          lcdTextLine1(instrumentMenu[menuItem]);
        }
      }
    }
    buttonReleased = 0;
  } //while(1) end
} //updateMenu() end)





//####################################################################
//################ SAVE / UPDATE SETTINGS FUNCTIONS: #################
void loadAllSettings(){
  breathRangeValue = loadIntSetting(breathRangeValue, 0);
  breathBufferValue = loadIntSetting(breathBufferValue, 2);
  breathMinValue = loadIntSetting(breathMinValue, 4);
  breathMaxValue = loadIntSetting(breathMaxValue, 6);
  bendPositionValue = loadIntSetting(bendPositionValue, 8);
  bendBufferValue = loadIntSetting(bendBufferValue, 10);
  bendMinValue = loadIntSetting(bendMinValue, 12);
  bendMidValue = loadIntSetting(bendMidValue, 14);
  bendMaxValue = loadIntSetting(bendMaxValue, 16);
  pickInstrValue = loadIntSetting(pickInstrValue, 18);
  transposeValue = loadIntSetting(transposeValue, 20);
  modeValue = loadByteSetting(modeValue, 22);
  intervalOctDist = loadIntSetting(intervalOctDist, 24);
}

int loadIntSetting(int value, int memPos){
  int tempInt = EEPROM.read(memPos);
  if(tempInt != value){
    value = tempInt;
    return(value);
  }
}
  
byte loadByteSetting(byte value, int memPos){
  byte tempByte = EEPROM.read(memPos);
  if(tempByte != value){
    value = tempByte;
    return(value);
  }
}

void saveAllSettings(){
  EEPROM.updateInt(0, breathRangeValue);
  EEPROM.updateInt(2, breathBufferValue);
  EEPROM.updateInt(4, breathMinValue);
  EEPROM.updateInt(6, breathMaxValue);
  EEPROM.updateInt(8, bendPositionValue);
  EEPROM.updateInt(10, bendBufferValue);
  EEPROM.updateInt(12, bendMinValue);
  EEPROM.updateInt(14, bendMidValue);
  EEPROM.updateInt(16, bendMaxValue);
  EEPROM.updateInt(18, pickInstrValue);
  EEPROM.updateInt(20, transposeValue);
  EEPROM.updateByte(22, modeValue); // Modes: 'N
  EEPROM.updateInt(24, intervalOctDist);
}

void restoreFactorySettings(){
  breathRangeValue = breathRangeValueFact;
  breathBufferValue = breathBufferValueFact;
  breathMinValue = breathMinValueFact;
  breathMaxValue = breathMaxValueFact;
  bendPositionValue = bendPositionValueFact;
  bendBufferValue = bendBufferValueFact;
  bendMinValue = bendMinValueFact;
  bendMidValue = bendMidValueFact;
  bendMaxValue = bendMaxValueFact;
  pickInstrValue = pickInstrValueFact;
  transposeValue = transposeValueFact;
  modeValue = modeValueFact;
  intervalOctDist = intervalOctDistFact;
}


//#################################################################
//#################################################################
// DEBOUNCE:
// Debounce function for buttons and keys
boolean debounce(byte pin, boolean last, byte debounceTime){
  boolean current = digitalRead(pin);
  if(last != current){
    delay(debounceTime);
    current = digitalRead(pin);
  }
  return current;
}


//###################################################################
//###################################################################
// SORT FUNCTION FOR THE MEDIAN FILTER:
void isort(int *a, int n){
  // *a is an array pointer, n is the array size
  for (int i = 1; i < n; ++i)
  {
    int j = a[i];
    int k;
    for (k = i - 1; (k >= 0) && (j < a[k]); k--)
    {
      a[k + 1] = a[k];
    }
    a[k + 1] = j;
  }
}
