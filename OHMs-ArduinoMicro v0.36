
//#####################################################
//#####################################################

// Open Horn Midi system / "OHMs"
// Arduino Micro - Main Code v0.36
// Copyright 2014, Jeppe Tofth√∏j Rasmussen

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//#####################################################
//#####################################################

#include <SoftwareSerial.h>
#include <SFE_BMP180.h>
#include <Wire.h>

//##############################################################
//##############################################################
// Velocity based output / after-touch based output




/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// KEY AND NOTE VARIABLES:

//Array of all pins with resistive touch switches - In descending fingering order: 
//             "" oUp oDn sF  B  A  G  G# A# F  E   D   D# ""
byte keyPins[] = {
  A1, A2, A3,   4,  5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
//(octaves)     HD  B  A  G  Ab Bb LC  F   E   D   Eb  LC/LBb
  
//        Pin = 14; // MISO pin
//        Pin = 15; // SCK pin 
#define NUMKEYS sizeof(keyPins)

#define NUMNOTEKEYS 12

//Fingering-arrays. Here I store all the different key combinations, in relation to the pins the keys are on.
// These arrays correspond to the "keyPins[]" array from [3] to [11], so pins from 4 - 12 carry these "note-defining" keys.
// The last three keys/pins are for octave and "special functions" and they are treated separately.

byte highEFlat[NUMNOTEKEYS] = {
  1,  0, 0, 0,  0, 1, 0,  0, 0, 0,  0, 0};
byte highDNat[NUMNOTEKEYS] = {
  1,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte cSharp[NUMNOTEKEYS] = {
  0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte cNat[NUMNOTEKEYS] = {
  0,  0, 1, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte bNat[NUMNOTEKEYS] = {
  0,  1, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte bFlat[NUMNOTEKEYS] = {
  0,  1, 1, 0,  0, 1, 0,  0, 0, 0,  0, 0};
byte aNat[NUMNOTEKEYS] = {
  0,  1, 1, 0,  0, 0, 0,  0, 0, 0,  0, 0};
byte aFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  1, 0, 0,  0, 0, 0,  0, 0};
byte gNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  0, 0, 0,  0, 0};
byte fSharp[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  0, 1, 0,  0, 0};
byte fNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 0, 0,  0, 0};
byte eNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 0,  0, 0};
byte eFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  1, 0};
byte dNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  0, 0};
  
byte lowCSharp[NUMNOTEKEYS] = {
  0,  1, 1, 1,  1, 0, 0,  1, 1, 1,  0, 1};
byte lowCNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 0,  1, 1, 1,  0, 1};
byte lowBNat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 1,  1, 1, 1,  0, 0};
byte lowBFlat[NUMNOTEKEYS] = {
  0,  1, 1, 1,  0, 0, 1,  1, 1, 1,  0, 1};
  



//Main array which stores the current state of each key:
byte keysPressed[NUMKEYS];

// Another array which stores the previous state for comparison:
byte lastPressed[NUMKEYS];

// A shorter version of the original key-array, with the octaves removed
byte noteKeysPressed[NUMNOTEKEYS];
boolean newKeys;

byte baseNote; // This is the initial reading of the note, and stores one of 18 notes between lowBFlat and highEFlat (46-63) 
byte currentNote; // This is the complete, calculated note, including octave.
byte lastNote; // This is the last played note, for comparison with new readings.
int octave = 0; // A value between -48 and 60 (in increments of 12). Set by setOctave()
int lastOctave = 0;




////////////////////////////////////////////
// BEND VARIABLES:
byte bendPin = A5; // Pin with the bend sensor on it

//pitchbend data storage:
byte lsb = 0;//least siginificant byte of pitchbend message (for 127 step resolution, this stays at 0)
byte bendTemp;
byte bendVal = 64;// (msb) most significant byte of pitchbend message (Bend values from 0 - 127. 64 means no pitchbend)
byte lastBend = 64;
byte refBend;
int potm;

byte bendCenter;
byte bendLowBuf;
byte bendHighBuf;




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// PREASSURE SENSOR VARIABLES:

// Pins for SDA and SCL are automatically set to pin2 (data) and pin3 (clock) by the BMP180 library (for Arduino Micro)

//int tempCount = 0;
//const int tempCountConstant = 20; // During reference measurements this is the number of Pressure measurements for each temp measurement
//const int refCountConstant = 100;
//const int pressBuffer = 3; // Buffer value for pressure reading noise. Lower than this difference to the ref pressure is ignored
//
//byte waitTime = 0; // This value is defined by the BMP180 when you ask it for a measurement.  
//                   // Value is then used in "timer1" to know when to read the reply
//unsigned long timer1;
//char status; // This is used together with "timer1" to keep track of the waitTime between temp or pressure measurements
//             // It is defined by the BMP180 and can be 0 or 1 or a small (byte) value in milliseconds.
//int currentTemp;
//int currentPressure = 0;
//int refPressure = 0;    // refPressure is calculated by averaging "refCountConstant" number of pressure readings
//
//int refCalcVal;         // refCalcVal is an intermediary step of adding ref and current pressures, before dividing by 2 to get the new ref
//
//byte refDone = 0;          // When this value is set to 0, the next "refCountConstant" number of 
//// pressure measurements will be used to calculate a new reference pressure.
//// Value starts at 0. When ref measurement is done it is automatically set to 1
//// It should be manually set back to 0 for a new reference measurement 
//// (button / rotary encoder ??)
//byte refCounter = 0; // This keeps track of the number of reference pressure measurements.
//// so that when refCounter >= refCountConstant, refDone is set to 1.
//
//byte velocity;     // This holds the mapped value of the currentPressure reading. Always a byte from 0-127.
//byte lastVelocity; // This holds the last velocity value for comparison
//
//int newVelocity = 0;
//
//double T,P,p0,a;  // These are the variables for holding the internal values of the BMP180 library
//// T = "Temperature", P = "Pressure", p0 = "pressure at 0 meters altitude", a = "altitude" 
//// "double" means "double precision float", which in arduino is the same size as "float"
//
//char pressureStatus = 1; // Used in "void updatePressure()". Has 4 modes: 
//// "1" New temp reading / "2" main temp reading / "3" new pressure reading / "4" main pressure reading
//// "1" and "2" (temperature) are only used for reference measurements, and are normally skipped in the loop.
//
//SFE_BMP180 pressure; // Create a pressure sensor object, called "pressure", from the BMP180 library
//
////#define ALTITUDE 0.0 // Float value for altitude calculation. Not used here




//#####################################################################
//#####################################################################
// FSR VARIABLES (Bite and Breath sensors):

byte bitePin = A0; // Pin with the bite sensor on it
int biteRead = 0;
byte biteVal = 0;
byte lastBite = 0;
byte harmonic = 0;

// harmonic limit constants for bite sensor:

const byte firstHarmonic = 800;
const byte secondHarmonic = 500;
const byte thirdHarmonic = 350;
const byte fourthHarmonic = 275;
const byte fifthHarmonic = 225;
const byte sixthHarmonic = 190;
const byte seventhHarmonic = 175;



byte fsrBreathPin = A4; // Pin with the breath sensor on it
int fsrBreathRead;
int fsrBreathTemp;
int fsrBreathCalc;
byte fsrBreathPressure;
byte fsrBreathSaved;

byte velocity;     // This holds the mapped value of the currentPressure reading. Always a byte from 0-127.
byte lastVelocity; // This holds the last velocity value for comparison

int newVelocity = 0;

///////////////////////////////////
//Median filter / Sort variables:
int arraySize = 10; 
int breathArray[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// ROTARY ENCODER VARIABLES:

int rotEncPin1 = 0;
int rotEncPin2 = 1;
int rotEncButtonPin = A4; 

volatile long lastEncoded = 0;
volatile long encoderValue = 0;
volatile long encoderOutput = 0;
volatile long lastEncoderOutput = 0;



///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// MIDI VARIABLES:


////////MIDI Commands:
byte noteON = 144;//144 = 10010000 in binary, this is the standard note on command
byte pitchBend = 224;//224 = 11100000 in binary, this is the standard pitchbend command
byte continuousController = 176;
byte sostenuto = 66;
byte footController = 4;
byte bankSelect = 0;
byte modulationControl = 1;


boolean sendMessage = 0; // If either of velocity, note or pitchBend have changed since last reading, this variable 
// is set to 1, and a new midi message will be sent this time around the loop.

//Pin = 14; // MISO pin
//Pin = 15; // SCK pin 
//Pin = 16; // MOSI pin

////Create a SoftwareSerial instance for sending MIDI commands out.
SoftwareSerial midiSerial(-1, 16);

byte Effect5Depth = 95;
byte Effect2Depth = 92;

// Serial 1-pin LCD setup:
// SoftwareSerial LCDSerial(-1, 16);


///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// SETUP:

void setup(){
  delay(5000);
  byte i;
  for (i=0; i < NUMKEYS; i++){
    pinMode(keyPins[i], INPUT);
    digitalWrite(keyPins[i], HIGH);
  }
  Serial.begin(9600);
  midiSerial.begin(31250);

//  // Initialize the pressure sensor:
//  if (pressure.begin())
//    Serial.println("BMP180 init success");
//  else
//  {
//    Serial.println("BMP180 init fail\n\n");
//    while(1); // If the BMP180 doesn't initiate, pause forever.
//  }


  // ROTARY ENCODER SETUP:
  pinMode(rotEncPin1, INPUT); 
  pinMode(rotEncPin2, INPUT);
  pinMode(rotEncButtonPin, INPUT);

  digitalWrite(rotEncPin1, HIGH); //turn pullup resistor on
  digitalWrite(rotEncPin2, HIGH); //turn pullup resistor on
  digitalWrite(rotEncButtonPin, HIGH); //turn pullup resistor on

  //call updateEncoder() when any high/low change seen
  //on interrupt 2 (pin 0), or interrupt 3 (pin 1) 
  attachInterrupt(2, rotEncUpdate, CHANGE); 
  attachInterrupt(3, rotEncUpdate, CHANGE);
  
  potm = analogRead(bendPin);
  bendCenter = map(potm, 440, 675, 0, 127);
  bendLowBuf = bendCenter - 5;
  bendHighBuf = bendCenter + 5;
}





///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// MAIN LOOP:


void loop(){
  int n;
  byte i;
//  timer1 = millis();              // Update timer1, to keep track of the pressure sensor wait time
//
  updatePressure();               // Updates pressure and velocity values
  if(velocity != lastVelocity){
    sendMessage = 1;
  }    // If the velocity has changed since last reading, "sendMessage" is set to 1, 
//    // and a new midi message will be sent this time around the loop.    
//  }
//
//  ///////////////////////////////////////////////////////////////////////
//  // Pressure reference measurements, only done at startup, or on command:
//  if(refDone == 0){                 // If the reference measurement series has not been done, or a new one has been requested, then do this loop:
//    if(newVelocity == 1){           // If there is a new complete pressure reading.
//      if(refCounter == 0){          // If it's the first time through
//        refPressure = currentPressure ;
//        refCounter ++;
//      }
//      else if(refCounter > 0 && refCounter < refCountConstant){ // If it's between the 2nd and the "refCountConstant" times through.
//        refCalcVal = refPressure + currentPressure;             // Partial calculation of average
//        refPressure = refCalcVal / 2;                           // refPressure is the average of the current ref and the new reading
//        refCounter ++;
//      }
//      else if(refCounter >= refCountConstant){                  // if it's the last time through.
//        refDone = 1;          // Reference is done. Don't do this loop again til asked.
//        refCounter = 0;
//        
//
//      }
//    }
//  } // End of pressure reference measurements
//  ///////////////////////////////////////////////////////////////////////


  //    Serial.print("Time in seconds: ");
  //    Serial.println(timer1 / 1000);
  //    Serial.print("Velocity:        ");
  //    Serial.println(velocity);
  //    delay(25);
  readKeys(); // This populates the "keysPressed[]" array with fresh readings from the 12 touch pins

    /////////////////////////////////////////////////
  //// Debug for "readKeys()" only:
  //  for (i = 0; i < NUMKEYS; i++){
  //    Serial.print(keysPressed[i]);
  //  }
  //  Serial.println();
  // // End debug /////////////////////////////////


  // Both "pickNote()" and "setOctave()" use the "keysPressed[]" array as an input

  pickNote();                    // picknote() function sets the "baseNote" as one of
  // midi note pitches from D natural up to middle C sharp, by  
  // comparing "keysPressed[]" to all accepted key combinations. 


  setOctave();                  // setOctave() function keeps track of the octave keys in the keysPressed[] array,
  //  if(octave != lastOctave){     // and updates it as an int between -48 and 60 (in increments of 12), which is
  //    sendMessage = 1;            // added to / subtracted from the note value
  //    lastOctave = octave;
  //  }

  currentNote = baseNote + octave + harmonic;  //Calculate final note value for midi, including octave

    if(currentNote != lastNote){   // Check for new note.
    sendMessage = 1;             // In case of new note, request new midi message
  }

  rotEncUpdate();
  if(encoderOutput != lastEncoderOutput){
    lastEncoderOutput = encoderOutput; 
    sendMessage = 1;
  }

  ////////////////////////////////////////////
  // Run the readBend function to update "bendValue":
  readBend();  // Update the bend value from the neck sensor and map it to 0 - 127.
  if(bendVal != lastBend){
    sendMessage = 1;

  }

//  readBite();
//  if(biteVal != lastBite){
//    sendMessage = 1;
//  }

  /////////////////////////////////////////////
  if(sendMessage == 1){

    if(currentNote != lastNote){
      sendMidi(noteON, currentNote, velocity);
      sendMidi(noteON, lastNote, 0);
      lastNote = currentNote;
    }

    if(velocity != 0 && lastVelocity == 0){
      sendMidi(noteON, currentNote, velocity);
    }

    if(velocity == 0){
      sendMidi(noteON, currentNote, 0);
      sendMidi(noteON, lastNote, 0);
    }

    if(velocity != lastVelocity){
      sendMidi(continuousController, 7, velocity);
    }   

    if(bendVal != lastBend){
      sendMidi(pitchBend, 0, bendVal);
      lastBend = bendVal;
    }
//    if(biteVal != lastBite){
//      sendMidi(modulationControl, 0, biteVal);
//      lastBite = biteVal;
//    }
    if(velocity != lastVelocity){
      lastVelocity = velocity;
    }


    sendMessage = 0;
    
//######### GENERAL DEBUG:
//    Serial.println();
////    Serial.print("Reference pressure:       ");
////    Serial.println(refPressure);
////    Serial.print("Current pressure:         ");
////    Serial.println(currentPressure);
//    Serial.print("Velocity:      ");
//    Serial.println(velocity);
//    Serial.print("Current Note:             ");
//    Serial.println(currentNote);
//    Serial.print("Note bend value:          ");
//    Serial.println(bendVal);
//    Serial.print("Rotary encoder position:  ");
//    Serial.println(encoderOutput);
//    delay(20);


  }
} // End of main loop
////////////////////////////////////////
///////////////////////////////////////





//#################################################################
//######################### Functions: ############################
//################################################################# 




//#################################################################
//#################################################################
// READ THE TOUCH KEYS:

void readKeys(){                      
  byte i;


  for (i = 0; i < NUMKEYS; i++){
    lastPressed[i] = keysPressed[i];
  }

  for (i = 0; i < NUMKEYS; i++){         // Call debounce for touch keys
    keysPressed[i] = debounce(keyPins[i], lastPressed[i], 3);
  }

  byte n = 0;
  for(i = 3; i < NUMKEYS; i++){
    noteKeysPressed[n] = keysPressed[i];
    n++;
  }
//  if(keysPressed[2] == 1 && keysPressed[8] == 1 && keysPressed[3] == 0){
//    refPressure = currentPressure;
//  }
}





//#################################################################
//#################################################################
// READ BEND SENSOR FUNCTION:

void readBend(){
  potm = analogRead(bendPin);
  bendTemp = map(potm, 440, 675, 0, 127);
  if(bendTemp != lastBend){
    if(bendTemp != refBend){
      if(bendTemp <= bendLowBuf){
      bendVal = map(bendTemp, 0, bendLowBuf, 0, 61);
      }
      else if(bendTemp >= bendHighBuf){
        bendVal = map(bendTemp, bendHighBuf, 127, 61, 127);
      }
      // This is the output value.
      else if(bendVal < bendHighBuf && bendVal > bendLowBuf){
        bendVal = 61;
      }
      refBend = lastBend;
    }
  }
      
}



//###################################################################
// FSR Breath pressure function - Sets velocity:
/////////////////////////////////////////////////////////
void updatePressure(){
  int i;
  for(i = 0; i < arraySize; i++){	
    fsrBreathTemp = analogRead(fsrBreathPin);
    breathArray[i] = fsrBreathTemp;
  }
  isort(breathArray,arraySize);
  fsrBreathRead = breathArray[arraySize / 2];
  if(fsrBreathRead > 780){   
    fsrBreathPressure = map(fsrBreathRead, 1023, 781, 0, 60);
  }
  else if(fsrBreathRead <= 780){   
    fsrBreathPressure = map(fsrBreathRead, 780, 500, 61, 127);
  }
  if(fsrBreathPressure > 127){
    fsrBreathPressure = 127;
  }
  if(fsrBreathPressure != fsrBreathSaved){
    velocity = fsrBreathPressure;
    fsrBreathSaved = fsrBreathPressure;
  }
}

//#################################################################
//#################################################################
// READ BITE SENSOR FUNCTION:

void readBite(){
  biteRead = analogRead(bitePin);
  biteVal = map(biteRead, 250, 0, 0, 127);

  if(biteVal <= firstHarmonic && biteVal > secondHarmonic){
    harmonic = 12;
  }
  else if(biteVal <= secondHarmonic && biteVal > thirdHarmonic){
    harmonic = 19;
  }
  else if(biteVal <= thirdHarmonic && biteVal > fourthHarmonic){
    harmonic = 24;
  }
  else if(biteVal <= fourthHarmonic && biteVal < fifthHarmonic){
    harmonic = 28;
  }
  else if(biteVal <= fifthHarmonic && biteVal < sixthHarmonic){
    harmonic = 31;
  }
  else if(biteVal <= sixthHarmonic && biteVal < seventhHarmonic){
    harmonic = 34;
  }
  else if(biteVal <= seventhHarmonic){
    harmonic = 36;
  }
}
      




//#################################################################
//#################################################################
// PICK A NOTE:
// Compare keysPressed[] from [3] to [12] to known key combinations, 
// and set "baseNote" as a midi pitch between between 50 and 61, notes 
// from dNat to cSharp:
void pickNote(){ 
  int i;
  boolean correct = 0;

  // Test for highEFlat:
  if(correct == 0){
    if(noteKeysPressed[0] == 1){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 1){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 63;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for highDNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 1){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 62;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for cSharp:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 61;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for cNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 0){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 60;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for bNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 0){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 59;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  // Test for bFlat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 1){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 58;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for aNat:    
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 0){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 57;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for aFlat: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 56;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for gNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 55;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for fSharp:
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 0){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 54;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for fNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 0){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 53;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for eNat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 0){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 52;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for eFlat:  
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 1){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 51;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for dNat: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 50;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Test for lowCSharp: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 1){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 49;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for lowCNat: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 0){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 48;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for lowBNat: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 0){
                            baseNote = 47;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  // Test for lowBFlat: 
  if(correct == 0){
    if(noteKeysPressed[0] == 0){
      
      if(noteKeysPressed[1] == 1){
        if(noteKeysPressed[2] == 1){
          if(noteKeysPressed[3] == 1){
            
            if(noteKeysPressed[4] == 0){
              if(noteKeysPressed[5] == 0){
                if(noteKeysPressed[6] == 1){
                  
                  if(noteKeysPressed[7] == 1){
                    if(noteKeysPressed[8] == 1){
                      if(noteKeysPressed[9] == 1){
                        
                        if(noteKeysPressed[10] == 0){
                          if(noteKeysPressed[11] == 1){
                            baseNote = 46;
                            correct = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  //  Serial.println("No note available...");
  //  Serial.println();
  //  delay(20);
}  // End of "void pickNote()"


//#################################################################
//#################################################################
// Octave Update Function:

void setOctave(){
  if(keysPressed[0] == 1){
    octave = 34;
  }

  if(keysPressed[1] == 1){
    octave = 10;
  }

  if(keysPressed[0] == 0 && keysPressed[1] == 0){
    octave = 22;
  }

  if(keysPressed[0] == 1 && keysPressed[1] == 1){
    octave = -2;
  }
}


/// OLD OCTAVE FUNCTION:
//void setOctave(){
//  if(keysPressed[0] == 1 && lastPressed[0] == 0){
//    octave = octave + 12;
//    if(octave > 60){
//      octave = 60;
//    }
//  }
//  if(keysPressed[1] == 1 && lastPressed[1] == 0){
//    octave = octave - 12;
//    if(octave + 48 < 0){
//      octave = octave + 12;
//    }
//  }
//}


//#################################################################
//#################################################################
// MIDI-Message function:

// sendMidi parameters  for noteOn are: Command, midiNote, midiVelocity
//                      for pitchBend are: Command, lsbBend, msbBend
void sendMidi(int command, int data1, int data2){ 
  midiSerial.write(command);//send command (noteOn / pitchBend etc)
  midiSerial.write(data1);//send data1 (pitch, lsbBend etc)
  midiSerial.write(data2);//send data2 (velocity, msbBend etc)
}





//
//void updatePressure(){
//  int i;
//  for(i = 0; i < 5; i++){
//    fsrBreathRead = analogRead(fsrBreathPin);
//    fsrBreathTemp = map(fsrBreathRead, 1023, 300, 0, 127);
//    fsrBreathCalc = fsrBreathCalc + fsrBreathTemp;
//  }
//  fsrBreathPressure = fsrBreathCalc / 5; 
//  fsrBreathCalc = 0;
//  if(fsrBreathPressure != fsrBreathSaved){
//    velocity = fsrBreathPressure;
//    fsrBreathSaved = fsrBreathPressure;
//  }
//}


//###################################################################
// BMP180 pressure sensor function with velocity output:
/////////////////////////////////////////////////////////
//void updatePressure(){
//  newVelocity = 0;
//  //  char status;
//  //  double T,P,p0,a;
//
//  //  if(pressureStatus = 0){
//  //    
//
//  if(pressureStatus == 1){
//    status = pressure.startTemperature();
//    if(status != 0){
//      waitTime = status + timer1;
//      pressureStatus = 2;
//    }
//  }
//
//  if(pressureStatus == 2){
//    if(timer1 > waitTime){
//      status = pressure.getTemperature(T);
//      if(status != 0){
//        currentTemp = (int) T;
//        pressureStatus = 3;
//      }
//    }
//  }
//
//  if(pressureStatus == 3){
//    status = pressure.startPressure(3);
//    if (status != 0){
//      waitTime = status + timer1;
//      pressureStatus = 4;
//    }
//  }
//
//  if(pressureStatus == 4){
//    if(timer1 > waitTime){
//      status = pressure.getPressure(P,T);
//      if(status != 0){
//        tempCount++;
//        currentPressure = (int) P;
//        if(refPressure > currentPressure || refPressure < currentPressure - 150){
//          refPressure = currentPressure;
//        }
//        velocity = map(currentPressure, refPressure + pressBuffer, 50 + refPressure, 0, 127);
//        newVelocity = 1;    
//        if(velocity > 127 && velocity < 245){
//          velocity = 127;
//        }
//        else if(velocity >= 245){
//          velocity = 0;
//        }
//
//        if(tempCount < tempCountConstant || refDone == 1){
//          pressureStatus = 3;
//        }
//        else{
//          pressureStatus = 1;
//          tempCount = 0;
//        }
//      }
//    } 
//  }
//}


//#################################################################
//#################################################################
//ROTARY ENCODER UPDATE FUNCTION:
//Called from interrupts on pins 0 and 1. 
//encoderOutput is a continuously changing value, counted from 0 at start position. 

void rotEncUpdate(){
  int MSB = digitalRead(rotEncPin1); //MSB = most significant bit
  int LSB = digitalRead(rotEncPin2); //LSB = least significant bit

  int encoded = (MSB << 1) | LSB; //converting the 2 pin value to single number
  int sum  = (lastEncoded << 2) | encoded; //adding it to the previous encoded value

  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValue ++;
  if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValue --;


  lastEncoded = encoded; 
  encoderOutput = encoderValue / 4;
}


//#################################################################
//#################################################################
// DEBOUNCE:
// Debounce function for buttons
boolean debounce(byte pin, boolean last, byte debounceTime){
  boolean current = digitalRead(pin);
  if(last != current){
    delay(debounceTime);
    current = digitalRead(pin);
  }
  return current;
}


//###################################################################
//###################################################################
// SORT FUNCTION FOR THE MEDIAN FILTER ON BREATH DATA:

void isort(int *a, int n){
// *a is an array pointer function - n is the array size

  for (int i = 1; i < n; ++i)
  {
    int j = a[i];
    int k;
    for (k = i - 1; (k >= 0) && (j < a[k]); k--)
    {
      a[k + 1] = a[k];
    }
    a[k + 1] = j;
  }

}
