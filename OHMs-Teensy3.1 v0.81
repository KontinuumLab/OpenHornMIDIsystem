
//#####################################################
//#####################################################
// Open Horn Midi system / "OHMs"
// Teensy 3.1 - Main Code v0.82
// Copyright 2016, Jeppe Tofth√∏j Rasmussen

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <Wire.h>

#include <SoftwareSerial.h>
//
SoftwareSerial uViewSerial(-1, 10);

//########### MPU9250 variables: ##############
boolean newGX = 0;
boolean newGY = 0;
boolean newGZ = 0;

int16_t gx = 0;
int16_t gy = 0;
int16_t gz = 0;

int16_t gxTemp = 0;
int16_t gyTemp = 0;
int16_t gzTemp = 0;

int16_t gxMin = 0;
int16_t gxMax = 8250;

int16_t gyMin = -8250;
int16_t gyMid = 0;
int16_t gyMax = 8250;
int16_t gyMidLowBuf = -200;
int16_t gyMidHighBuf= 200;
int16_t gyBuffer = 1500;

int16_t gzMin = 0;
int16_t gzMax = 8250;


#define G_ARRAY_LENGTH 20
int gyroArrayCounter = 0;
int16_t gxArray[G_ARRAY_LENGTH];
int16_t gyArray[G_ARRAY_LENGTH];
int16_t gzArray[G_ARRAY_LENGTH];
byte GX = 0;
byte GXLast = 0;
byte GX2ndLast = 0;

byte GY = 0;
byte GYLast = 0;
byte GY2ndLast = 0;

byte GZ = 0;
byte GZLast = 0;
byte GZ2ndLast = 0;

#define    MPU9250_ADDRESS            0x69
//#define    MAG_ADDRESS                0x0C

#define    GYRO_FULL_SCALE_250_DPS    0x00  
#define    GYRO_FULL_SCALE_500_DPS    0x08
#define    GYRO_FULL_SCALE_1000_DPS   0x10
#define    GYRO_FULL_SCALE_2000_DPS   0x18

#define    ACC_FULL_SCALE_2_G        0x00  
#define    ACC_FULL_SCALE_4_G        0x08
#define    ACC_FULL_SCALE_8_G        0x10
#define    ACC_FULL_SCALE_16_G       0x18




// Calibration button Variables:
int btnPin1 = 17;
int btnPin2 = 20;
int btnPin3 = 16;
int btn1Read = 1;
int btn2Read = 1;
int btn3Read = 1;
int btn1ReadLast = 1;
int btn2ReadLast = 1;
int btn3ReadLast = 1;

// ENCODER VARIABLES:
int encPin1 = 13;
int encPin2 = 14;
int encButtonPin = 15;


int encDir; 
boolean currentEncButton = 0;
boolean encBtnPressed;
boolean encBtnReleased;
boolean newValueBool = 0;

int encCounter; 
int lastEncCounter;

int encVal1 = 0;
int encVal2 = 0;
int encLastVal1 = 0;
int encLastVal2 = 0;
int encButtonVal = 0;
int encButtonLastVal = 0;


// KEY VARIABLES:
                //0, 1,  2,  3,  4,  5, 6,  7, 8, 9, 10, 11,12,13, 14, 15, 16,17, 18, 19
//byte keyPins[] = {2, 24, 23, 22, 21, 9, 12, 7, 4, 6, 11, 5, 8, 26, 29, 27, 3, 30, 28, 25};
//{2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};
byte keyPins[] = {2, 30, 29, 27, 28, 9, 11, 4, 6, 7, 8, 5, 12, 23, 25, 21, 3, 26, 22, 24};
  
  
#define NUMKEYS sizeof(keyPins)

//Main array which stores the current state of each key pin:
byte keysPressed[NUMKEYS];
// Another array which stores the previous state for comparison:
byte lastPressed[NUMKEYS];

unsigned long checkTimer = 0;
unsigned long lastCheckTime = 0;

boolean newNote;
boolean correct;

byte baseNote;       
byte currentNote;    
byte lastNote;       
int octave = 0;      
int lastOctave = 0;

byte splitLowPressed; //"bitwrite" variable
byte splitHighPressed; //"bitwrite" variable


byte currentSplitHighNote;
byte duplicateSplitHighNote;
byte currentSplitLowNote;
byte lastSplitHighNote;
byte lastSplitLowNote;
byte currentSplitNote;
byte lastSplitNote;

boolean splitActive = 0;
boolean lastSplitActive = 0;


byte currentSustainNote;
byte lastSustainNote;
boolean sustainActive = 0;
boolean lastSustainActive = 0;

byte sustainInterval;

byte currentIntervalNote;
boolean intervalActive = 0;
boolean lastIntervalActive = 0;

// BREATH VARIABLES:
byte breathPin = A10; // Pin with the breath sensor on it
int breathRead;
int breathMidLow = 240;
int breathMidHigh = 241;
int breathTemp;
int breathCalc;
byte breathPressure;
byte breathSaved;
byte velocity; 
byte lastVelocity;

int breathBuffer = 10;
int breathMin = 0;
int breathMax = 1023;

int breathArraySize = 100;
int breathArray[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };



// BEND VARIABLES:
int potm;
int bendPin = A12;
byte bendTemp = 0;
byte bend = 0;
byte bendSaved = 0;
int bendMin = 0;
int bendMax = 1023;
int bendBuffer = 20; // user settable
int bendLowBuf = 0;
int bendHighBuf = 0;
int bendMid = 0;

int bendArraySize = 25;
int bendArray[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


//#####################################################################
//########################   MIDI VARIABLES:  #########################
//MIDI MIDIcommands:
byte noteONCh1 = 144;
byte noteONCh2 = 145;
byte noteOFFCh2 = 129;

byte pitchBend = 224;
byte continuousController = 176;
byte sostenuto = 66;
byte footController = 4;
byte bankSelect = 0;
byte modulationControl = 1;

boolean sendCh1NoteMessage = 0;
boolean sendCh2NoteMessage = 0;
boolean sendBendMessage = 0;   
boolean sendBreathMessage = 0;


// This function read Nbytes bytes from I2C device at address Address. 
// Put read bytes starting at register Register in the Data array. 
void I2Cread(uint8_t Address, uint8_t Register, uint8_t Nbytes, uint8_t* Data)
{
  // Set register address
  Wire.beginTransmission(Address);
  Wire.write(Register);
  Wire.endTransmission();
  
  // Read Nbytes
  Wire.requestFrom(Address, Nbytes); 
  uint8_t index=0;
  while (Wire.available())
    Data[index++]=Wire.read();
}


// Write a byte (Data) in device (Address) at register (Register)
void I2CwriteByte(uint8_t Address, uint8_t Register, uint8_t Data)
{
  // Set register address
  Wire.beginTransmission(Address);
  Wire.write(Register);
  Wire.write(Data);
  Wire.endTransmission();
}

void setup() { 
  int n;
  for(n = 0; n < NUMKEYS; n++){
    pinMode(keyPins[n], INPUT);
  }
  pinMode(encPin1, INPUT_PULLUP);
  pinMode(encPin2, INPUT_PULLUP);
  pinMode(encButtonPin, INPUT_PULLUP);
  
  pinMode(btnPin1, INPUT_PULLUP);
  pinMode(btnPin2, INPUT_PULLUP);
  pinMode(btnPin3, INPUT_PULLUP);

  Wire.begin();
  Serial.begin(115200);
  Serial1.begin(9600);
  uViewSerial.begin(9600);
  
//#######################################  
//  Setup MPU9250 Accelerometer, gyroscope and magnetometer:

  // Set accelerometers low pass filter at 5Hz
  I2CwriteByte(MPU9250_ADDRESS,29,0x06);
  // Set gyroscope low pass filter at 5Hz
  I2CwriteByte(MPU9250_ADDRESS,26,0x06);
 
  
  // Configure gyroscope range
  I2CwriteByte(MPU9250_ADDRESS,27,GYRO_FULL_SCALE_1000_DPS);
  // Configure accelerometers range
  I2CwriteByte(MPU9250_ADDRESS,28,ACC_FULL_SCALE_4_G);
//  // Set by pass mode for the magnetometers
  I2CwriteByte(MPU9250_ADDRESS,0x37,0x02);
//  
//  // Request continuous magnetometer measurements in 16 bits
//  I2CwriteByte(MAG_ADDRESS,0x0A,0x16);

  delay(2000);
  
  
  int i;
  for(i = 0; i < breathArraySize; i++){
    breathTemp = analogRead(breathPin);
    breathArray[i] = breathTemp;
  }
  isort(breathArray,breathArraySize);
  breathRead = breathArray[breathArraySize / 2];
  breathMin = breathRead + breathBuffer;
  
  bendMid = analogRead(bendPin);
  bendLowBuf = bendMid - bendBuffer;
  bendHighBuf = bendMid + bendBuffer;
  
  
}



//##############################################################
//##############################################################
//######################## MAIN LOOP: ##########################


void loop(){
// BUTTON CHECK:
//(Will be menu call)
//  quickEncRead();
//  if(encButtonVal == 0){
  
  encRead();
  if(encBtnPressed == 1){
//    Serial.println("Button pressed");
    uViewSerial.print('#');
  }
  if(encBtnReleased == 1){
//    Serial.println("Button Released");
    uViewSerial.print('$');
  }
//  }
//

//##############################
// #########  Calibration call:
  quickReadCalBtns();
  if(btn1Read == 0 || btn2Read == 0 || btn3Read == 0){
    readCalButtons();
    if(btn1Read == 0){
      breathMax = 0;
      breathMin = 1023;
//      Serial.println("Calibrating Breath...");
      while(btn1Read == 0){
        calibrateBreath();
        readCalButtons();
      }
    }
    
    if(btn2Read == 0){
      potm = analogRead(bendPin);
      bendMid = potm;
      
      bendMax = 0;
      bendMin = 1023;
//      Serial.println("Calibrating Bend...");
      while(btn2Read == 0){
        calibrateBend();
        readCalButtons();
      }
//      Serial.println("Calibrating Bend...");
      while(btn2Read == 0){
        calibrateBend();
        readCalButtons();
      }
      int bendMidTemp = bendMid;
      potm = analogRead(bendPin);
      bendMid = (potm + bendMidTemp) / 2;
      bendLowBuf = bendMid - bendBuffer;
      bendHighBuf = bendMid + bendBuffer;
    }
    
    if(btn3Read == 0){
      gxMin = 8250;
      gxMax = 0;
      gyMin = 8250;
      gyMax = -8250;
      gzMin = 8250;
      gzMax = 0;
      while(btn3Read == 0){
        calibrateIMU();
        readCalButtons();
      }
      gyMid = gy;
      gyMidLowBuf = gyMid - gyBuffer;
      gyMidHighBuf = gyMid + gyBuffer;
    }
  }
  

  updatePressure();
  
  if(velocity != lastVelocity){
    if(velocity == 0){
//      xBeeMIDI(noteONCh1, currentNote, 0);
//      xBeeMIDI(noteONCh1, lastNote, 0);
//      xBeeMIDI(noteONCh2, currentSplitNote, 0);
//      xBeeMIDI(noteONCh2, lastSplitNote, 0);
      if(splitActive == 1){
//        sendMessage(note, currentSplitLowNote, 0, 1); // generic "send" function
//        sendMessage(notercurrentSplitHighNote, 0, 2);
        usbMIDI.sendNoteOn(currentSplitLowNote, 0, 1);
        usbMIDI.sendNoteOn(currentSplitHighNote, 0, 2);        
      }
      else{
        if(sustainActive == 1){
          usbMIDI.sendNoteOn(currentSustainNote, 0, 1);
          usbMIDI.sendNoteOn(currentNote, 0, 2);
          }
        else{
          usbMIDI.sendNoteOn(currentNote, 0, 1);
        }
      }
    }
    else if(lastVelocity == 0){
      breathTimerStart = millis();
      if(correct == 1){
//          xBeeMIDI(noteONCh1, currentNote, velocity);
        if(splitActive == 0){
          if(sustainActive == 1){
            usbMIDI.sendNoteOn(currentSustainNote, velocity, 1);
            usbMIDI.sendNoteOn(currentNote, velocity, 2);
          }
          else{
            usbMIDI.sendNoteOn(currentNote, velocity, 1);
          }
        }
        else{
//            xBeeMIDI(noteONCh2, currentSplitNote, velocity);
          usbMIDI.sendNoteOn(currentSplitLowNote, velocity, 1);
          usbMIDI.sendNoteOn(currentSplitHighNote, velocity, 2);
        }
      }
    }
    else{
//        xBeeMIDI(continuousController, 2, velocity);
      breathTimer = millis();
      if(breathTimer - breathTimerStart > breathMessageDelay){
        usbMIDI.sendControlChange(2, velocity, 1);
        breathTimerStart = millis();
      }
    }
  }
  
  
  readBend();
  if(bend != bendSaved){
//    xBeeMIDI(pitchBend, 0, bend);
    usbMIDI.sendPitchBend(bend, 1);
  }

//  updateIMU();
//  if(newGX == 1){
//    usbMIDI.sendControlChange(12, GX, 1); // CC#12 = Effect Controller 1
//    newGX = 0;
//  }
//  if(newGY == 1){
//    usbMIDI.sendControlChange(1, GY, 1); // CC#1 = Modulation / Vibrato
//    newGY = 0;
//  }
//  if(newGZ == 1){
//    usbMIDI.sendControlChange(4, GZ, 1); // CC#4 = Foot controller / Aftertouch
//    newGZ = 0;
//  }
  
  readKeys();  // Accesses readKeys(), readKeyPins(), keyLogic() and pickSplit(), as needed
  if(velocity != 0){
    if(splitActive == 0){
      if(lastSplitActive == 1){
//          xBeeMIDI(noteONCh2, lastSplitNote, 0);
//          xBeeMIDI(noteONCh2, currentSplitNote, 0);
//          xBeeMIDI(noteONCh1, lastNote, 0);
//          xBeeMIDI(noteONCh1, currentNote, 0);
        usbMIDI.sendNoteOn(currentSplitLowNote, 0, 1);
        usbMIDI.sendNoteOn(currentSplitHighNote, 0, 2);
      }
      
      if(sustainActive == 1 && intervalActive == 0){
        if(lastSustainActive == 0){
          currentSustainNote = currentNote;
          usbMIDI.sendNoteOn(currentNote, velocity, 2);
        }
      }
      else if(sustainActive == 1 && intervalActive == 1){
        if(lastIntervalActive == 0){
          sustainInterval = currentSustainNote - currentNote;
        }
        lastSustainNote = currentSustainNote;
        currentSustainNote = currentNote + sustainInterval;
      }
      else if(lastSustainActive == 1){
        usbMIDI.sendNoteOn(currentSustainNote, 0, 1);
        usbMIDI.sendNoteOn(currentNote, 0, 2);
        usbMIDI.sendNoteOn(currentNote, velocity, 1);
      }
      
      if(newNote == 1){
        if(sustainActive == 1){
          usbMIDI.sendNoteOn(lastNote, 0, 2);
          usbMIDI.sendNoteOn(currentNote, velocity, 2);
          if(intervalActive == 1){
            usbMIDI.sendNoteOn(lastSustainNote, 0, 1);
            usbMIDI.sendNoteOn(currentSustainNote, velocity, 1);
          }         
        }
        else{
//          xBeeMIDI(noteONCh1, lastNote, 0);
//          xBeeMIDI(noteONCh1, currentNote, velocity);
          usbMIDI.sendNoteOn(lastNote, 0, 1);
          usbMIDI.sendNoteOn(currentNote, velocity, 1);
        }
      }
    }
    
    else if(splitActive == 1){
      if(lastSplitActive == 0){
        if(sustainActive == 1){
          usbMIDI.sendNoteOn(currentNote, 0, 2);
          usbMIDI.sendNoteOn(currentSustainNote, 0, 1);
        }
        else{
          usbMIDI.sendNoteOn(currentNote, 0, 1);
        }
        usbMIDI.sendNoteOn(currentSplitLowNote, velocity, 1);
        usbMIDI.sendNoteOn(currentSplitHighNote, velocity, 2);
      }
      else{
        if(currentSplitLowNote != lastSplitLowNote){
  //          xBeeMIDI(noteONCh1,lastNote, 0);
  //          xBeeMIDI(noteONCh1, currentNote, velocity);
          usbMIDI.sendNoteOn(lastSplitLowNote, 0, 1);
          usbMIDI.sendNoteOn(currentSplitLowNote, velocity, 1);
        }
        if(currentSplitHighNote != lastSplitHighNote){
  //          xBeeMIDI(noteONCh2,lastSplitNote, 0);
  //          xBeeMIDI(noteONCh2,currentSplitNote, velocity);
          usbMIDI.sendNoteOn(lastSplitHighNote, 0, 2);
          usbMIDI.sendNoteOn(currentSplitHighNote, velocity, 2);
        }
      }
    }
  }
  else{
    if(sustainActive == 1 && intervalActive == 0){
      if(lastSustainActive == 0){
        currentSustainNote = currentNote;
//        usbMIDI.sendNoteOn(currentNote, velocity, 2);
      }
    }
    else if(sustainActive == 1 && intervalActive == 1){
      if(lastIntervalActive == 0){
        sustainInterval = currentSustainNote - currentNote;
      }
      lastSustainNote = currentSustainNote;
      currentSustainNote = currentNote + sustainInterval;
    }
  }
    

  while (usbMIDI.read());
//  delay(10);
}

//##################### :END MAIN LOOP #########################
//##############################################################
//##############################################################









//void quickEncRead(){
//  encButtonVal = digitalRead(encButtonPin);
//}
//  

void encRead(){
  //READ pins:
  encLastVal1 = encVal1;
  encLastVal2 = encVal2;
  encButtonLastVal = encButtonVal;
  
  encVal1 = debounce(encPin1, encLastVal1, 1);
  encVal2 = debounce(encPin2, encLastVal2, 1);
  encButtonVal = debounce(encButtonPin, encButtonLastVal, 1);
  

  // ENCODER:

  encDir = 0;
  if(encVal1 == 1 && encLastVal1 == 0){
    if(encVal2 == 0){
      encDir = -1;
    }
    else{
      encDir = 1;
    }
  }
  if(encButtonVal == 0 && encButtonLastVal == 1){
    encBtnPressed = 1;
    encBtnReleased = 0;
  }
  else if(encButtonVal == 1 && encButtonLastVal == 0){
    encBtnPressed = 0;
    encBtnReleased = 1;
  }
  else{
    encBtnPressed = 0;
    encBtnReleased = 0;
  }
  
  encCounter += encDir;
}

void quickReadCalBtns(){
  btn1Read = digitalRead(btnPin1);
  btn2Read = digitalRead(btnPin2);
  btn3Read = digitalRead(btnPin3);  
}

void readCalButtons(){
  btn1ReadLast = btn1Read;
  btn2ReadLast = btn2Read;
  btn3ReadLast = btn3Read;  
  btn1Read = debounce(btnPin1, btn1ReadLast, 2);
  btn2Read = debounce(btnPin2, btn1ReadLast, 2);
  btn3Read = debounce(btnPin3, btn1ReadLast, 2);
}







void updatePressure(){
  lastVelocity = velocity;
    
  int i;
  for(i = 0; i < breathArraySize; i++){
    breathTemp = analogRead(breathPin);
    breathArray[i] = breathTemp;
  }
  isort(breathArray,breathArraySize);
  breathRead = breathArray[breathArraySize / 2];
//  breathPressure = map(breathRead, breathMin, breathMax, 1, 127);
  
  
//  breathRead = map(breathRead, 1023, 0, 0, 1023); // Reverse the input

  if(breathRead < breathMin){
    breathPressure = 0;
  }
  else{
    if(breathRead <= breathMax){
      breathPressure = map(breathRead, breathMin, breathMax, 1, 127);
    }
    else if(breathRead > breathMax){
      breathPressure = 127;
    }
  }
  if(breathPressure != breathSaved){
    velocity = breathPressure;
    breathSaved = breathPressure;
  }
}

void calibrateBreath(){
  int i;
  for(i = 0; i < breathArraySize; i++){
    breathTemp = analogRead(breathPin);
    breathArray[i] = breathTemp;
  }
  isort(breathArray,breathArraySize);
  breathRead = breathArray[breathArraySize / 2];
//  breathRead = map(breathRead, 1023, 0, 0, 1023);
  if(breathRead > breathMax){
    breathMax = breathRead;
  }
  if(breathRead < breathMin){
    breathMin = breathRead + breathBuffer;
  }
}

//void breathCalSetup(){
//  int i;
//  for(i = 0; i < breathArraySize; i++){
//    breathTemp = analogRead(breathPin);
//    breathArray[i] = breathTemp;
//  }
//  isort(breathArray,breathArraySize);
//  breathRead = breathArray[breathArraySize / 2];
//  breathMin = breathRead + breathBuffer;
//
//}

void readBend(){
  bendSaved = bend;
  potm = analogRead(bendPin);
  
  if(potm <= bendLowBuf){
//    bendTemp = map(potm, bendMin, bendLowBuf, 0, 63);
    bend = map(potm, bendMin, bendLowBuf, 0, 63);
  }
  else if(potm >= bendHighBuf){
//    bendTemp = map(potm, bendHighBuf, bendMax, 65, 127);
//    if(bendTemp != bendSaved){
    bend = map(potm, bendHighBuf, bendMax, 65, 127);
//    }
  }
  // bend is the output value.
  else if(potm > bendLowBuf && potm < bendHighBuf){
    bend = 64;
  }
}

void calibrateBend(){
  potm = analogRead(bendPin);
//  int i;
//  for(i = 0; i < bendArraySize; i++){
//    bendTemp = analogRead(bendPin);
//    bendArray[i] = bendTemp;
//  }
//  isort(bendArray,bendArraySize);
//  potm = bendArray[bendArraySize / 2];
//  
  if(potm > bendMax){
    bendMax = potm;
  }
  if(potm < bendMin){
    bendMin = potm;
  }
}




void updateIMU(){
  uint8_t Buf[14];
  // Read accelerometer and gyroscope
  I2Cread(MPU9250_ADDRESS,0x3B,14,Buf);
  
  updateGyro(Buf);
  gyroArrayCounter++;
}



void updateGyro(uint8_t *buffer){ 
  gxTemp=-(buffer[0]<<8 | buffer[1]);
  gyTemp=-(buffer[2]<<8 | buffer[3]);
  gzTemp=buffer[4]<<8 | buffer[5];
  
  gxArray[gyroArrayCounter] = gxTemp;
  gyArray[gyroArrayCounter] = gyTemp;
  gzArray[gyroArrayCounter] = gzTemp;
  
  
  if(gyroArrayCounter >= G_ARRAY_LENGTH){

    GX2ndLast = GXLast;
    GXLast = GX;    
    isort16(gxArray, G_ARRAY_LENGTH);
    int gArrayMedian = G_ARRAY_LENGTH / 2;

    gx = gxArray[gArrayMedian];
    if(gx > gxMax){
      GX = 0;
    }
    else if(gx < gxMin){
      GX = 127;
    }
    else{
      GX = map(gx, gxMax, gxMin, 0, 127);
    }


    GY2ndLast = GYLast;
    GYLast = GY;    
    isort16(gyArray, G_ARRAY_LENGTH);
    gy = gyArray[gArrayMedian];
    if(gy > gyMax){
      GY = 127;
    }
    else if(gy < gyMin){
      GY = 0;
    }
    else if(gy >= gyMidHighBuf){
      GY = map(gy, gyMidHighBuf, gyMax, 65, 127);
    }
    else if(gy <= gyMidLowBuf){
      GY = map(gy, gyMin, gyMidLowBuf, 0, 63);
    }
    else{   
      GY = 64;
    }
    

    GZ2ndLast = GZLast;
    GZLast = GZ;        
    isort16(gzArray, G_ARRAY_LENGTH);
    gz = gzArray[gArrayMedian];
    if(gz > gzMax){
      GZ = 127;
    }
    else if(gz < gzMin){
      GZ = 0;
    }
    else{   
      GZ = map(gz, gzMin, gzMax, 0, 127);
    }
    checkNewGX();
    checkNewGY();
    checkNewGZ();
    gyroArrayCounter = 0;
  }
}

void calibrateIMU(){
  uint8_t Buf[14];
  // Read accelerometer and gyroscope
  I2Cread(MPU9250_ADDRESS,0x3B,14,Buf);
  
  calibrateGyro(Buf);
  gyroArrayCounter++;
}

void calibrateGyro(uint8_t *buffer){ 
  gxTemp=-(buffer[0]<<8 | buffer[1]);
  gyTemp=-(buffer[2]<<8 | buffer[3]);
  gzTemp=buffer[4]<<8 | buffer[5];
  
  gxArray[gyroArrayCounter] = gxTemp;
  gyArray[gyroArrayCounter] = gyTemp;
  gzArray[gyroArrayCounter] = gzTemp;
  
  
  if(gyroArrayCounter >= G_ARRAY_LENGTH){

//    GX2ndLast = GXLast;
//    GXLast = GX;    
    isort16(gxArray, G_ARRAY_LENGTH);
    int gArrayMedian = G_ARRAY_LENGTH / 2;

    gx = gxArray[gArrayMedian];
    if(gx > gxMax){
      gxMax = gx;
    }
    else if(gx < gxMin){
      gxMin = gx;
    }


//    GY2ndLast = GYLast;
//    GYLast = GY;

    isort16(gyArray, G_ARRAY_LENGTH);
    gy = gyArray[gArrayMedian];
    if(gy > gyMax){
      gyMax = gy;
    }
    else if(gy < gyMin){
      gyMin = gy;
    }
    

//    GZ2ndLast = GZLast;
//    GZLast = GZ;        
    isort16(gzArray, G_ARRAY_LENGTH);
    gz = gzArray[gArrayMedian];
    if(gz > gzMax){
      gzMax = gz;
    }
    else if(gz < gzMin){
      gzMin = gz;
    }
    
    gyroArrayCounter = 0;
  }
}


void checkNewGX(){
  if(GX > GXLast){
    if(GX - GX2ndLast > 2){

        newGX = 1;

    }
  }
  else if(GX < GXLast){
    if(GX2ndLast - GX > 2){

        newGX = 1;

    }
  }
}

void checkNewGY(){
  if(GY > GYLast){
    if(GY - GY2ndLast > 2){

        newGY = 1;

    }
  }
  else if(GY < GYLast){
    if(GY2ndLast - GY > 2){

        newGY = 1;

    }
  }
}

void checkNewGZ(){
  if(GZ > GZLast){
    if(GZ - GZ2ndLast > 2){

        newGZ = 1;

    }
  }
  else if(GZ < GZLast){
    if(GZ2ndLast - GZ > 2){

        newGZ = 1;

    }
  }
}

//#################################################################
//#################################################################
// READ THE TOUCH KEYS:

void readKeys(){
  correct = 0;
  newNote = 0;
    
  readKeyPins();
  byte i;  
  if(keysPressed[0] == 0){
    checkTimer = millis();
    lastCheckTime = checkTimer;
  }
  else if(keysPressed[0] == 1){
    checkTimer = millis();
  }

  if(checkTimer - lastCheckTime > 10){
    keyLogic();
//    for(i = 0; i < NUMKEYS; i++){
//      if(keysPressed[i] != lastPressed[i]){
//        newNote = 1;
//        break;
//      }
//    }
  }
}

void readKeyPins(){
  byte j;
  for (j = 0; j < NUMKEYS; j++){
    lastPressed[j] = keysPressed[j];
  }
  for (j = 0; j < NUMKEYS; j++){ // Call debounce for touch keys
    keysPressed[j] = digitalRead(keyPins[j]); // Original debounceTime = 8
  }
}


//#################################################################
//#################################################################
// KEY LOGIC:
void keyLogic(){

  lastNote = currentNote;
  setOctave();
    
  lastSustainActive = sustainActive;
  lastIntervalActive = intervalActive;  
  if(keysPressed[13] == 1){
    sustainActive = 1;
    if(keysPressed[5] == 0){
      intervalActive = 0;
    }
    else if(keysPressed[5] == 1){
      intervalActive = 1;
    }
  }
  else{
    sustainActive = 0;
    intervalActive = 0;
  }
 
 
  lastSplitActive = splitActive; 
  if(keysPressed[5] == 1 && keysPressed [13] == 0){
    splitActive = 1;
    pickSplit();
  }
  else{
    splitActive = 0;
    
// Test for highEFlat:
    if(correct == 0){
      
      if(keysPressed[6] == 1){
        
        if(keysPressed[7] == 0){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 0){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 1){
                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 63;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
                      
                    }
                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for highDNat:
    if(correct == 0){
      
      if(keysPressed[6] == 1){
        
        if(keysPressed[7] == 0){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 0){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 0){
                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 62;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
                      
                    }
                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for highcSharp:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 0){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 0){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
//                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 61;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
//                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for highcNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 0){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
//                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 60;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
//                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for highbNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
          if(keysPressed[8] == 0){
            if(keysPressed[9] == 0){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 0){
                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 59;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
                    }
                    
//                  }
//                }
              }
            }
          }
        }
        
      }
      
    }
// Test for highbFlat-"1":
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
          if(keysPressed[8] == 1){
            if(keysPressed[9] == 0){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 0){
                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 58;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
                    }
                    
//                  }
//                }
              }
            }
          }
        }
        
      }
      
    }
// Test for highbFlat-"2":
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 1){
                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 58;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
                      
                    }
                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for aNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 0){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
                    if(keysPressed[14] == 0){
                      
//                      if(keysPressed[15] == 0){
//                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 57;
                                correct = 1;
//                              }
//                            }
//                          }
//                        }
//                      }
                      
                    }
                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for aFlat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
                if(keysPressed[11] == 1){
//                  if(keysPressed[12] == 0){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 0){
                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 56;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
//                    }
                    
//                  }
                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for gNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 0){
                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 55;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
//                    }
                    
//                  }
                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for fSharp:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 0){
                        if(keysPressed[16] == 1){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 54;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for fNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 0){
//                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 53;
                                correct = 1;
//                              }
//                            }
//                          }
                        }
                      }
                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for eNat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 0){
//                            if(keysPressed[18] == 0){
//                              if(keysPressed[19] == 0){
                                baseNote = 52;
                                correct = 1;
//                              }
//                            }
                          }
                        }
                      }
                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for eFlat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
//                  if(keysPressed[12] == 0){
//                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
                            if(keysPressed[18] == 1){
                              if(keysPressed[19] == 0){
                                baseNote = 51;
                                correct = 1;
                              }
                            }
                          }
                        }
                      }
                      
//                    }
//                    
//                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for lowD:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
                  if(keysPressed[12] == 0){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
                            if(keysPressed[18] == 0){
                              if(keysPressed[19] == 0){
                                baseNote = 50;
                                correct = 1;
                              }
                            }
                          }
                        }
                      }
                      
//                    }
                    
                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for lowCSharp:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
                if(keysPressed[11] == 1){
                  if(keysPressed[12] == 0){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
//                            if(keysPressed[18] == 0){
                              if(keysPressed[19] == 1){
                                baseNote = 49;
                                correct = 1;
                              }
//                            }
                          }
                        }
                      }
                      
//                    }
                    
                  }
                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for lowC:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
                if(keysPressed[11] == 0){
                  if(keysPressed[12] == 0){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
                            if(keysPressed[18] == 0){
                              if(keysPressed[19] == 1){
                                baseNote = 48;
                                correct = 1;
                              }
                            }
                          }
                        }
                      }
                      
//                    }
                    
                  }
                }
              }
            }
//          }
        }
        
      }
      
    }
// Test for lowB:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
                  if(keysPressed[12] == 1){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
                            if(keysPressed[18] == 0){
                              if(keysPressed[19] == 0){
                                baseNote = 47;
                                correct = 1;
                              }
                            }
                          }
                        }
                      }
                      
//                    }
                    
                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }    
// Test for lowBFlat:
    if(correct == 0){
      
      if(keysPressed[6] == 0){
        
        if(keysPressed[7] == 1){
//          if(keysPressed[8] == 0){
            if(keysPressed[9] == 1){
              if(keysPressed[10] == 1){
//                if(keysPressed[11] == 0){
                  if(keysPressed[12] == 1){
                    
//                    if(keysPressed[14] == 0){
                      
                      if(keysPressed[15] == 1){
                        if(keysPressed[16] == 1){
                          if(keysPressed[17] == 1){
                            if(keysPressed[18] == 0){
                              if(keysPressed[19] == 1){
                                baseNote = 46;
                                correct = 1;
                              }
                            }
                          }
                        }
                      }
                      
//                    }
                    
                  }
//                }
              }
            }
//          }
        }
        
      }
      
    }
    if(correct == 1){
      currentNote = baseNote + octave;
      if(currentNote != lastNote){
        newNote = 1;
      }
    }
  } 
  

}

//#################################################################
//##################    PICK INTERVAL:    #########################

void pickSplit(){
  lastSplitHighNote = currentSplitHighNote;
  lastSplitLowNote = currentSplitLowNote;
  
  bitWrite(splitHighPressed, 0, keysPressed[11]);
  bitWrite(splitHighPressed, 1, keysPressed[10]);
  bitWrite(splitHighPressed, 2, keysPressed[9]);
  bitWrite(splitHighPressed, 3, keysPressed[7]);
  byte n = 0;
  byte i;
  for(i = 18; i > 14; i--){
    bitWrite(splitLowPressed, n, keysPressed[i]);
    n++;
  }
  
  if(splitHighPressed != 0){
    correct = 1;
    currentSplitHighNote = splitHighPressed + octave + 47;
    if(splitLowPressed != 0){
      currentSplitLowNote = splitLowPressed + octave + 47; //(+ splitOctaveDistance)
    }
    else{
      currentSplitLowNote = currentSplitHighNote;
    }
//  
//    if(correct == 1){
//      if(currentSplitHighNote != lastSplitHighNote || currentSplitLowNote != lastSplitLowNote){
//        newNote = 1;
//      }
//    }
  }
}


//#################################################################
//#################    Octave Update Function:    #################
void setOctave(){
  if     (keysPressed[1] == 0 && keysPressed[2] == 1 && keysPressed[3] == 1 && keysPressed[4] == 1){
    octave = 48;
  }
  else if(keysPressed[1] == 0 && keysPressed[2] == 0 && keysPressed[3] == 0 && keysPressed[4] == 1){
    octave = 36;
  }
  else if(keysPressed[1] == 0 && keysPressed[2] == 0 && keysPressed[3] == 1 && keysPressed[4] == 1){
    octave = 24;
  }
  else if(keysPressed[1] == 0 && keysPressed[2] == 0 && keysPressed[3] == 1 && keysPressed[4] == 0){
    octave = 12;
  }
  else if(keysPressed[1] == 0 && keysPressed[2] == 1 && keysPressed[3] == 1 && keysPressed[4] == 0){
    octave = 0;
  }
  else if(keysPressed[1] == 0 && keysPressed[2] == 1 && keysPressed[3] == 0 && keysPressed[4] == 0){
    octave = -12;
  }
  else if(keysPressed[1] == 1 && keysPressed[2] == 1 && keysPressed[3] == 0 && keysPressed[4] == 0){
    octave = -24;
  }
  else if(keysPressed[1] == 1 && keysPressed[2] == 0 && keysPressed[3] == 0 && keysPressed[4] == 0){
    octave = -36;
  }
  else if(keysPressed[1] == 1 && keysPressed[2] == 1 && keysPressed[3] == 1 && keysPressed[4] == 0){
    octave = -48;
  }
//  else if(keysPressed[1] == 0 && keysPressed[2] == 0 && keysPressed[3] == 0 && keysPressed[4] == 0){
//    octave = 48;
//  }
//  octave = octave + transposeValue; // Transpose operation from menu settings
}



//#################################################################
//#################################################################
// DEBOUNCE:
// Debounce function for buttons and keys
boolean debounce(byte pin, boolean last, byte debounceTime){
  boolean current = digitalRead(pin);
  if(last != current){
    delay(debounceTime);
    current = digitalRead(pin);
  }
  return current;
}

//###################################################################
//###################################################################
// SORT FUNCTION FOR THE MEDIAN FILTER:
void isort(int *a, int n){
  // *a is an array pointer, n is the array size
  for (int i = 1; i < n; ++i)
  {
    int j = a[i];
    int k;
    for (k = i - 1; (k >= 0) && (j < a[k]); k--)
    {
      a[k + 1] = a[k];
    }
    a[k + 1] = j;
  }
}

void isort16(int16_t *a, int n){
  // *a is an array pointer, n is the array size
  for (int i = 1; i < n; ++i)
  {
    int j = a[i];
    int k;
    for (k = i - 1; (k >= 0) && (j < a[k]); k--)
    {
      a[k + 1] = a[k];
    }
    a[k + 1] = j;
  }
}

//#################################################################
//#################################################################
// MIDI-Message function:
// xBeeMIDI parameters for noteONCh1 are: MIDIcommand, midiNote, midiVelocity
// for pitchBend are: MIDIcommand, lsbBend, msbBend
//void xBeeMIDI(byte MIDIcommand, byte data1, byte data2){
//  Serial1.write(MIDIcommand);//send MIDIcommand (noteONCh1 / pitchBend etc)
//  Serial1.write(data1);//send data1 (pitch, lsbBend etc)
//  Serial1.write(data2);//send data2 (velocity, msbBend etc)
//}
